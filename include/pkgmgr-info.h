/*
 * pkgmgr-info
 *
 * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
 *
 * Contact: Jayoun Lee <airjany@samsung.com>, Sewook Park <sewook7.park@samsung.com>,
 * Jaeho Lee <jaeho81.lee@samsung.com>, Shobhit Srivastava <shobhit.s@samsung.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * @file		pkgmgr-info.h
 * @author		Sewook Park <sewook7.park@samsung.com>
 * @author		Shobhit Srivastava <shobhit.s@samsung.com>
 * @version		0.1
 * @brief		This file declares API of pkgmgr-info library
 *
 * @addtogroup		APPLICATION_FRAMEWORK
 * @{
 *
 * @defgroup		PackageManagerInfo
 * @section		Header Header file to include:
 * @code
 * #include		<pkgmgr-info.h>
 * @endcode
 *
 * @}
 */

#ifndef __PKG_INFO_H__
#define __PKG_INFO_H__

#include <errno.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/types.h>

#include "pkgmgrinfo_type.h"

#ifdef __cplusplus
extern "C" {
#endif


/**
 * @mainpage
 *
 * This is package information library
 *
 * Package Information Library is used to get package related information.\n
 * It uses the package manifest information database to get any package related information\n
 * It also provides API to set information in the package info database\n
 *
 */

/**
 * @file	pkgmgr-info.h
 * @brief	Package Information Library Header File
 *
 * Generated by    Sewook Park <sewook7.park@samsung.com>
 */



 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_ID		"PMINFO_PKGINFO_PROP_PACKAGE_ID"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_TYPE	"PMINFO_PKGINFO_PROP_PACKAGE_TYPE"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_VERSION	"PMINFO_PKGINFO_PROP_PACKAGE_VERSION"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_INSTALL_LOCATION		"PMINFO_PKGINFO_PROP_PACKAGE_INSTALL_LOCATION"
  /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_INSTALLED_STORAGE		"PMINFO_PKGINFO_PROP_PACKAGE_INSTALLED_STORAGE"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_NAME		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_NAME"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_EMAIL		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_EMAIL"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_HREF		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_HREF"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_PRIVILEGE		"PMINFO_PKGINFO_PROP_PACKAGE_PRIVILEGE"

 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_REMOVABLE		"PMINFO_PKGINFO_PROP_PACKAGE_REMOVABLE"
 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD		"PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD"
 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_READONLY		"PMINFO_PKGINFO_PROP_PACKAGE_READONLY"
  /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_UPDATE		"PMINFO_PKGINFO_PROP_PACKAGE_UPDATE"
  /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_APPSETTING		"PMINFO_PKGINFO_PROP_PACKAGE_APPSETTING"
   /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_NODISPLAY_SETTING		"PMINFO_PKGINFO_PROP_PACKAGE_NODISPLAY_SETTING"
   /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_SUPPORT_DISABLE		"PMINFO_PKGINFO_PROP_PACKAGE_SUPPORT_DISABLE"

 /** Integer property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_SIZE		"PMINFO_PKGINFO_PROP_PACKAGE_SIZE"

 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ID		"PMINFO_APPINFO_PROP_APP_ID"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_COMPONENT		"PMINFO_APPINFO_PROP_APP_COMPONENT"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_EXEC		"PMINFO_APPINFO_PROP_APP_EXEC"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ICON		"PMINFO_APPINFO_PROP_APP_ICON"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_TYPE		"PMINFO_APPINFO_PROP_APP_TYPE"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_OPERATION	"PMINFO_APPINFO_PROP_APP_OPERATION"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_URI			"PMINFO_APPINFO_PROP_APP_URI"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_MIME		"PMINFO_APPINFO_PROP_APP_MIME"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_CATEGORY	"PMINFO_APPINFO_PROP_APP_CATEGORY"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_HWACCELERATION	"PMINFO_APPINFO_PROP_APP_HWACCELERATION"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_SCREENREADER	"PMINFO_APPINFO_PROP_APP_SCREENREADER"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_PACKAGE		"PMINFO_APPINFO_PROP_APP_PACKAGE"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_METADATA_KEY	"PMINFO_APPINFO_PROP_APP_METADATA_KEY"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_METADATA_VALUE	"PMINFO_APPINFO_PROP_APP_METADATA_VALUE"

 /** Integer property for filtering app disabled by user*/
#define	PMINFO_APPINFO_PROP_APP_DISABLE_FOR_USER	"PMINFO_APPINFO_PROP_APP_DISABLE_FOR_USER_VALUE"

 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_NODISPLAY		"PMINFO_APPINFO_PROP_APP_NODISPLAY"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_MULTIPLE		"PMINFO_APPINFO_PROP_APP_MULTIPLE"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ONBOOT			"PMINFO_APPINFO_PROP_APP_ONBOOT"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_AUTORESTART	"PMINFO_APPINFO_PROP_APP_AUTORESTART"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_TASKMANAGE	"PMINFO_APPINFO_PROP_APP_TASKMANAGE"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_LAUNCHCONDITION	"PMINFO_APPINFO_PROP_APP_LAUNCHCONDITION"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_UI_GADGET	"PMINFO_APPINFO_PROP_APP_UI_GADGET"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_DISABLE	"PMINFO_APPINFO_PROP_APP_DISABLE"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_SUPPORT_DISABLE	"PMINFO_APPINFO_PROP_APP_SUPPORT_DISABLE"

 /** will be updated*/
 /** string property for filtering based on pkg info*/
#define	PMINFO_PKGINFO_PROP_RANGE_BASIC	"PMINFO_PKGINFO_PROP_RANGE_BASIC"

/* For multiuser support */
const char *getIconPath(uid_t uid, bool readonly);
const char *getUserPkgParserDBPath(void);
const char *getUserPkgParserDBPathUID(uid_t uid);
const char *getUserPkgCertDBPath(void);
const char *getUserPkgCertDBPathUID(uid_t uid);
const char *getUserManifestPath(uid_t uid, bool readonly);

/**
 * @fn	int pkgmgrinfo_pkginfo_get_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data)
 * @fn	int pkgmgrinfo_pkginfo_get_usr_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data, uid_t uid)
 * @brief	This API gets list of installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	pkg_list_cb	iteration function for list
 * @param[in]	user_data	user data to be passed to callback function
 * @param[in]	uid	the addressee user id of the instruction
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post	None
 * @code
int pkg_list_cb(pkgmgrinfo_pkginfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_pkginfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_pkgs()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_pkginfo_get_list(pkg_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data);
int pkgmgrinfo_pkginfo_get_usr_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data, uid_t uid);
/**
 * @fn int pkgmgrinfo_pkginfo_get_pkginfo(const char *pkgid, pkgmgrinfo_pkginfo_h *handle)
 * @brief	This API creates the package information handle from db
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	pkgid	pointer to package ID
 * @param[in]	uid	the addressee user id of the instruction
 * @param[out] handle		pointer to the package info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkginfo(const char *pkgid, pkgmgrinfo_pkginfo_h *handle);
int pkgmgrinfo_pkginfo_get_usr_pkginfo(const char *pkgid, uid_t uid, pkgmgrinfo_pkginfo_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_get_pkgname(pkgmgrinfo_pkginfo_h handle, char **pkg_name)
 * @brief	This API gets the package name from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out]	pkg_name	pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_type()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_name(const char *pkgid)
{
	int ret = 0;
	char *pkgname = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_pkgname(handle, &pkgname);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgname: %s\n", pkgname);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkgname(pkgmgrinfo_pkginfo_h handle, char **pkg_name);

/**
 * @fn int pkgmgrinfo_pkginfo_get_pkgid(pkgmgrinfo_pkginfo_h handle, char **pkgid)
 * @brief	This API gets the package id from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out]	pkgid	pointer to hold package id
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_type()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkgid(const char *pkgid)
{
	int ret = 0;
	char *pkg_id = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_pkgid(handle, &pkg_id);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg id: %s\n", pkg_id);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkgid(pkgmgrinfo_pkginfo_h handle, char **pkgid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_type(pkgmgrinfo_pkginfo_h handle, char **type)
 * @brief	This API gets the package type from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] type		pointer to hold package type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_type(pkgmgrinfo_pkginfo_h handle, char **type);

/**
 * @fn int pkgmgrinfo_pkginfo_get_version(pkgmgrinfo_pkginfo_h handle, char **version)
 * @brief	This API gets the package version from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] version		pointer to hold package version
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_version(const char *pkgid)
{
	int ret = 0;
	char *version = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_version(handle, &version);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg version: %s\n", version);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_version(pkgmgrinfo_pkginfo_h handle, char **version);

/**
 * @fn int pkgmgrinfo_pkginfo_get_api_version(pkgmgrinfo_pkginfo_h handle, char **api_version)
 * @brief	This API gets the package api_version from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] api_version		pointer to hold package api_version
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_api_version(const char *pkgid)
{
	int ret = 0;
	char *api_version = NULL;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_api_version(handle, &api_version);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg api_version: %s\n", api_version);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_api_version(pkgmgrinfo_pkginfo_h handle, char **api_version);

/**
 * @fn int pkgmgrinfo_pkginfo_get_tep_name(pkgmgrinfo_pkginfo_h handle, char **tep_name)
 * @brief	This API gets tep(tizen expansion package) file name associated with the package
 *
 * @par	This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle 		pointer to the pkginfo handle.
 * @param[out] tep_name 	pointer to hold tep name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK success
 * @retval	PMINFO_R_EINVAL invalid argument
 * @retval	PMINFO_R_ERROR  internal error
 * @pre	pkgmgrinfo_pkginfo_get_pkginfo()
 * @post 		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see	pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_tep_name(const char *pkgid)
{
	int ret = 0;
	char *tep_name = NULL;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_tep_name(handle, &tep_name);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("TEP name is: %s\n", tep_name);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_tep_name(pkgmgrinfo_pkginfo_h handle, char **tep_name);

/**
 * @fn int pkgmgrinfo_pkginfo_get_zip_mount_file(pkgmgrinfo_pkginfo_h handle, char **zip_mount_file)
 * @brief	This API gets package mount point path associated with the package
 *			if package is mount-installed. Otherwise, zip_mount_file is left as NULL value
 *
 * @par	This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle 		pointer to the pkginfo handle.
 * @param[out] zip_mount_file 	pointer to hold zip mount file
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK success
 * @retval	PMINFO_R_EINVAL invalid argument
 * @retval	PMINFO_R_ERROR  internal error
 * @pre	pkgmgrinfo_pkginfo_get_pkginfo()
 * @post 	pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see	pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_zip_mount_file(const char *pkgid)
{
	int ret = 0;
	char *zip_mount_file = NULL;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_zip_mount_file(handle, &zip_mount_file);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	if (zip_mount_file != NULL)
		printf("Zip mount path is: %s\n", zip_mount_file);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_zip_mount_file(pkgmgrinfo_pkginfo_h handle, char **zip_mount_file);

/**
 * @fn int pkgmgrinfo_pkginfo_get_install_location(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_install_location *location)
 * @brief	This API gets the package install location from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to package info handle
 * @param[out] location		pointer to hold package install location
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_install_location(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_install_location location;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_install_location(handle, &location);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg install location: %d\n", location);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_install_location(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_install_location *location);

/**
 * @fn int pkgmgrinfo_pkginfo_get_package_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the package size from the package ID. size will be 0 if package install location is internal-only.
 size will be 0 if package install location is prefer-external but size is not specified in manifest file.Application should check
 the return value of pkgmgrinfo_pkginfo_get_install_location() and use it to distinguish the above cases.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_package_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgsize: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_package_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_total_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the installed package total size on the target.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package total size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_pkg_total_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_total_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg total size: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_pkginfo_get_total_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_data_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the installed package data size on the target.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package data size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_pkg_data_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_data_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg data size: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_pkginfo_get_data_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_icon(pkgmgrinfo_pkginfo_h handle, char **icon)
 * @brief	This API gets the package icon from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] icon		pointer to hold package icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_icon(const char *pkgid)
{
	int ret = 0;
	char *icon = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_icon(handle, &icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg icon: %s\n", icon);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_icon(pkgmgrinfo_pkginfo_h handle, char **icon);

/**
 * @fn int pkgmgrinfo_pkginfo_get_label(pkgmgrinfo_pkginfo_h handle, char **label)
 * @brief	This API gets the package label from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] label		pointer to hold package label
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_label(const char *pkgid)
{
	int ret = 0;
	char *label = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_label(handle, &label);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg label: %s\n", label);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_label(pkgmgrinfo_pkginfo_h handle, char **label);

/**
 * @fn int pkgmgrinfo_pkginfo_get_description(pkgmgrinfo_pkginfo_h handle, char **description)
 * @brief	This API gets the package description from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] description		pointer to hold package description
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_description(const char *pkgid)
{
	int ret = 0;
	char *description = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_description(handle, &description);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg description: %s\n", description);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_description(pkgmgrinfo_pkginfo_h handle, char **description);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_name(pkgmgrinfo_pkginfo_h handle, char **author_name)
 * @brief	This API gets the package's author name from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_name		pointer to hold package author name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_name(const char *pkgid)
{
	int ret = 0;
	char *author_name = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_name(handle, &author_name);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author name: %s\n", author_name);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_name(pkgmgrinfo_pkginfo_h handle, char **author_name);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_email(pkgmgrinfo_pkginfo_h handle, char **author_email)
 * @brief	This API gets the package's author email from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_email		pointer to hold package author email
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_email(const char *pkgid)
{
	int ret = 0;
	char *author_email = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_email(handle, &author_email);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author email: %s\n", author_email);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_email(pkgmgrinfo_pkginfo_h handle, char **author_email);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_href(pkgmgrinfo_pkginfo_h handle, char **author_href)
 * @brief	This API gets the package's author href from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_href		pointer to hold package author href
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_href(const char *pkgid)
{
	int ret = 0;
	char *author_href = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_href(handle, &author_href);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author href: %s\n", author_href);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_href(pkgmgrinfo_pkginfo_h handle, char **author_href);

/**
 * @fn int pkgmgrinfo_pkginfo_get_installed_storage(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_installed_storage *storage)
 * @brief	This API gets the package installed storagae value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] storage		pointer to hold package installed storage
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_installed_storage(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_installed_storage storage;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_installed_storage(handle, &storage);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg installed storage: %d\n", storage);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_installed_storage(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_installed_storage *storage);

/**
 * @fn int pkgmgrinfo_pkginfo_get_installed_time(pkgmgrinfo_pkginfo_h handle, int *installed_time)
 * @brief	This API gets the installed time of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] installed_time		pointer to hold installed time of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_installed_time(const char *pkgid)
{
	int ret = 0;
	int installed_time = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_installed_time(handle, &installed_time);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("installed_time: %d\n", installed_time);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_installed_time(pkgmgrinfo_pkginfo_h handle, int *installed_time);

/**
 * @fn int pkgmgrinfo_appinfo_get_launch_mode(pkgmgrinfo_appinfo_h handle, char **mode)
 * @brief	This API gets the launch mode of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] mode		pointer to hold launch mode of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_launch_mode(const char *pkgid)
{
	int ret = 0;
	char *launch_mode = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_launch_mode(handle, &mode);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("launch mode: %s\n", mode);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_launch_mode(pkgmgrinfo_appinfo_h handle, char **mode);

/**
 * @fn int pkgmgrinfo_pkginfo_get_storeclientid(pkgmgrinfo_pkginfo_h handle, char **storeclientid)
 * @brief	This API gets the store client id of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] storeclientid		pointer to hold store client id of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_storeclientid(const char *pkgid)
{
	int ret = 0;
	char *storeclientid = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_storeclientid(handle, &storeclientid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf(store client id: %s\n", storeclientid);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_storeclientid(pkgmgrinfo_pkginfo_h handle, char **storeclientid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_mainappid(pkgmgrinfo_pkginfo_h handle, char **mainappid)
 * @brief	This API gets the main app id of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] mainappid		pointer to hold main app id of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_mainappid(const char *pkgid)
{
	int ret = 0;
	char *mainappid = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_mainappid(handle, &mainappid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf(main app id: %s\n", mainappid);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_mainappid(pkgmgrinfo_pkginfo_h handle, char **mainappid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_url(pkgmgrinfo_pkginfo_h handle, char **url)
 * @brief	This API gets the url of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] url		pointer to hold url of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_url(const char *pkgid)
{
	int ret = 0;
	char *url = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_url(handle, &url);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("url : %s\n", url);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_url(pkgmgrinfo_pkginfo_h handle, char **url);

/**
 * @fn int pkgmgrinfo_pkginfo_get_root_path(pkgmgrinfo_pkginfo_h handle, char **path)
 * @brief	This API gets the root path of package
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to package info handle
 * @param[out] path		pointer to hold root path of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_root_path(const char *pkgid)
{
	int ret = 0;
	char *path = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_pkginfo_get_root_path(handle, &path);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("path : %s\n", path);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_root_path(pkgmgrinfo_pkginfo_h handle, char **path);


/**
 * @fn int pkgmgrinfo_pkginfo_get_csc_path(pkgmgrinfo_pkginfo_h handle, char **path)
 * @brief	This API gets the csc path of package
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to package info handle
 * @param[out] path		pointer to hold csc path of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_csc_path(const char *pkgid)
{
	int ret = 0;
	char *path = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_pkginfo_get_csc_path(handle, &path);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("path : %s\n", path);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_csc_path(pkgmgrinfo_pkginfo_h handle, char **path);

/**
 * @fn int pkgmgrinfo_pkginfo_compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
 * @brief	This API compare the cert information from given package id
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	lhs_package_id	pointer to first package ID
 * @param[in]	rhs_package_id	pointer to second package ID
 * @param[out] compare_result		pointer to the compare result.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
{
	int ret = 0;
	pkgmgrinfo_cert_compare_result_type_e result;

	ret = pkgmgrinfo_pkginfo_compare_pkg_cert_info(lhs_package_id, rhs_package_id, &result);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	printf("result: %d\n", result);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result);
int pkgmgrinfo_pkginfo_compare_usr_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, uid_t uid, pkgmgrinfo_cert_compare_result_type_e *compare_result);
/**
 * @fn int pkgmgrinfo_pkginfo_compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
 * @brief	This API compare the cert information from given app id
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	lhs_app_id	pointer to first app ID
 * @param[in]	rhs_app_id	pointer to second app ID
 * @param[out] compare_result		pointer to the compare result.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
{
	int ret = 0;
	pkgmgrinfo_cert_compare_result_type_e result;

	ret = pkgmgrinfo_pkginfo_compare_app_cert_info(lhs_app_id, rhs_app_id, &result);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	printf("result: %d\n", result);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result);
int pkgmgrinfo_pkginfo_compare_usr_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, uid_t uid, pkgmgrinfo_cert_compare_result_type_e *compare_result);
/**
 * @fn int pkgmgrinfo_pkginfo_is_removable(pkgmgrinfo_pkginfo_h handle, bool *removable)
 * @brief	This API gets the package 'removable' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] removable		pointer to hold package removable value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_removable(const char *pkgid)
{
	int ret = 0;
	bool removable;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_removable(handle, &removable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg removable: %d\n", removable);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_removable(pkgmgrinfo_pkginfo_h handle, bool *removable);

/**
 * @fn int pkgmgrinfo_pkginfo_is_movable(pkgmgrinfo_pkginfo_h handle, bool *movable)
 * @brief	This API check that the package can move internal storage to external storage or external storage to internal storage from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] movable		pointer to hold package movable state
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_pkg_movable(const char *pkgid)
{
	int ret = 0;
	bool movable;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_movable(handle, &movable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg movable: %d\n", movable);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_movable(pkgmgrinfo_pkginfo_h handle, bool *movable);

/**
 * @fn int pkgmgrinfo_pkginfo_is_preload(pkgmgrinfo_pkginfo_h handle, bool *preload)
 * @brief	This API gets the package 'preload' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] preload		pointer to hold package preload value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_preload(const char *pkgid)
{
	int ret = 0;
	bool preload;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_preload(handle, &preload);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg preload: %d\n", preload);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_preload(pkgmgrinfo_pkginfo_h handle, bool *preload);

/**
 * @fn int pkgmgrinfo_pkginfo_is_system(pkgmgrinfo_pkginfo_h handle, bool *system)
 * @brief	This API gets the value for given handle is system or not
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] system		pointer to hold  system is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_system(const char *pkgid)
{
	int ret = 0;
	bool system = false;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_system(handle, &system);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg system: %d\n", system);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_system(pkgmgrinfo_pkginfo_h handle, bool *system);

/**
 * @fn int pkgmgrinfo_pkginfo_is_readonly(pkgmgrinfo_pkginfo_h handle, bool *readonly)
 * @brief	This API gets the package 'readonly' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] readonly	pointer to hold package readonly value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_readonly(const char *pkgid)
{
	int ret = 0;
	bool readonly;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_readonly(handle, &readonly);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg readonly: %d\n", readonly);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_readonly(pkgmgrinfo_pkginfo_h handle, bool *readonly);


/**
 * @fn int pkgmgrinfo_pkginfo_is_update(pkgmgrinfo_pkginfo_h handle, bool *update)
 * @brief	This API gets the package 'upate' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] update	pointer to hold package update value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_pkg_update(const char *pkgid)
{
	int ret = 0;
	bool update;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_update(handle, &update);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg update: %d\n", update);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_update(pkgmgrinfo_pkginfo_h handle, bool *update);

/**
 * @fn int pkgmgrinfo_pkginfo_is_support_disable(pkgmgrinfo_pkginfo_h handle, bool *support_disable)
 * @brief	This API gets the package 'support_disable' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out]	support_disable	pointer to hold package support_disable value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_pkg_support_disable(const char *pkgid)
{
	int ret = 0;
	bool support_disable;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_support_disable(handle, &support_disable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg support_disable: %d\n", support_disable);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_support_disable(pkgmgrinfo_pkginfo_h handle, bool *support_disable);

/**
 * @fn int pkgmgrinfo_pkginfo_is_global(pkgmgrinfo_pkginfo_h handle, bool *global)
 * @brief	This API gets whethere the given package is global package or user package
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[in]	global	pointer to hold package global value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 static int get_pkg_support_disable(const char *pkgid)
 {
	 int ret = 0;
	 bool global;
	 pkgmgrinfo_pkginfo_h handle = NULL;
	 ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	 if (ret != PMINFO_R_OK)
		 return -1;
	 ret = pkgmgrinfo_pkginfo_is_global(handle, &global);
	 if (ret != PMINFO_R_OK) {
		 pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		 return -1;
	 }
	 printf("pkg is_global: %d\n", global);
	 pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	 return 0;
 }
  * @endcode
  */
int pkgmgrinfo_pkginfo_is_global(pkgmgrinfo_pkginfo_h handle, bool *global);

/**
 * @fn int pkgmgrinfo_pkginfo_is_accessible(pkgmgrinfo_pkginfo_h handle, bool *accessible)
 * @brief	This API gets the package 'accessible' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] accessible	pointer to hold package accessible value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_accessible(const char *pkgid)
{
	int ret = 0;
	bool accessible;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_accessible(handle, &accessible);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg accessible: %d\n", accessible);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_accessible(pkgmgrinfo_pkginfo_h handle, bool *accessible);

/**
 * @fn int pkgmgrinfo_pkginfo_destroy_pkginfo(pkgmgrinfo_pkginfo_h handle)
 * @brief	This API destroys the package information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to the package info handle
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_destroy_pkginfo(pkgmgrinfo_pkginfo_h handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_create(pkgmgrinfo_pkginfo_filter_h *handle)
 * @brief	This API creates the package information filter handle from db.  All filter properties will be ANDed.
 The query will search the entire package information collected from the manifest file of all the installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_tpk_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "tpk");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of tpk pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_create(pkgmgrinfo_pkginfo_filter_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_destroy(pkgmgrinfo_pkginfo_filter_h handle)
 * @brief	This API destroys the package information filter handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_tpk_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "tpk");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of tpk pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_destroy(pkgmgrinfo_pkginfo_filter_h handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_bool(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const bool value)
 * @brief	This API adds a boolean filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		boolean property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_preload_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_bool(handle, PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of preload pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_bool(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const bool value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_int(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const int value)
 * @brief	This API adds an integer filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		integer property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_int(handle, PMINFO_PKGINFO_PROP_PACKAGE_SIZE, 10);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of preload pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_int(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const int value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_string(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const char *value)
 * @brief	This API adds a string filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		string property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_tpk_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "tpk");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of tpk pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_string(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const char *value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_foreach_pkginfo(pkgmgrinfo_pkginfo_filter_h handle, pkgmgrinfo_pkg_list_cb pkg_cb, void *user_data)
 * @brief	This API executes the user supplied callback function for each package that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] pkg_cb		callback function.
 * @param[in] user_data		user data to be passed to the callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @code
int pkg_list_cb(pkgmgrinfo_pkginfo_h handle, void *user_data)
{
	char *pkgid = NULL;
	pkgmgrinfo_pkginfo_get_pkgid(handle, &pkgid);
	printf("pkg id : %s\n", pkgid);
	return 0;
}

static int get_tpk_pkg_list()
{
	int ret = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "tpk");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_foreach_pkginfo(handle, pkg_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_foreach_pkginfo(pkgmgrinfo_pkginfo_filter_h handle,
		pkgmgrinfo_pkg_list_cb pkg_cb, void *user_data);
int pkgmgrinfo_pkginfo_usr_filter_foreach_pkginfo(pkgmgrinfo_pkginfo_filter_h handle,
		pkgmgrinfo_pkg_list_cb pkg_cb, void *user_data, uid_t uid);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count)
 * @fn int pkgmgrinfo_pkginfo_usr_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count, uid_t uid)
 * @brief	This API counts the package that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] count		pointer to store the count value.
 * @param[in]	uid	the addressee user id of the instruction
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_tpk_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "tpk");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of tpk pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count);
int pkgmgrinfo_pkginfo_usr_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count, uid_t uid);
/**
 * @fn	int pkgmgrinfo_pkginfo_foreach_privilege(pkgmgrinfo_pkginfo_h handle,
			pkgmgrinfo_pkg_privilege_list_cb privilege_func, void *user_data);
 * @brief	This API gets the list of privilege for a particular package
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the package info handle.
 * @param[in]	privilege_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @code
int privilege_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_privilege(const char *package, char *privilege)
{
	int ret = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(package, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_foreach_privilege(handle, privilege_func, (void *)privilege);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_foreach_privilege(pkgmgrinfo_pkginfo_h handle,
			pkgmgrinfo_pkg_privilege_list_cb privilege_func, void *user_data);

/* TODO: add doxygen comment here */
int pkgmgrinfo_pkginfo_get_size_from_xml(const char *manifest, int *size);
int pkgmgrinfo_pkginfo_get_location_from_xml(const char *manifest, pkgmgrinfo_install_location *location);
int pkgmgrinfo_pkginfo_is_for_all_users(pkgmgrinfo_pkginfo_h handle, bool *for_all_users);
int pkgmgrinfo_appinfo_set_state_enabled(const char *appid, bool enabled);
int pkgmgrinfo_appinfo_set_usr_state_enabled(const char *appid, bool enabled, uid_t uid);
int pkgmgrinfo_appinfo_set_default_label(const char *appid, const char *label);
int pkgmgrinfo_appinfo_set_usr_default_label(const char *appid, const char *label, uid_t uid);

/**
 * @fn int pkgmgrinfo_appinfo_clone_appinfo(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_pkginfo_h *clone)
 * @brief	This API copy the application information handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to the package info handle.
 * @param[out]	handle	pointer to the package info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
static int get_appinfo_clone(pkgmgrinfo_pkginfo_h handle)
{
	int ret = 0;

	pkgmgrinfo_pkginfo_h clone;

	ret = pkgmgrinfo_appinfo_clone_appinfo(handle, &clone);
	if (ret != PMINFO_R_OK)
		return -1;


	printf("package: %s\n", clone->package);
	pkgmgrinfo_appinfo_destroy_appinfo(clone);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_clone_appinfo(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_pkginfo_h *clone);


/**
 * @fn	int pkgmgrinfo_appinfo_get_list(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_app_component component,
 pkgmgrinfo_app_list_cb app_func, void *user_data)
 * @brief	This API gets list of installed applications for a particular package
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		package info handle
 * @param[in]	component	application component
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @code
int app_func(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int list_apps(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_list(handle, PMINFO_UI_APP, app_func, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_list(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_app_component component,
							pkgmgrinfo_app_list_cb app_func, void *user_data);
int pkgmgrinfo_appinfo_get_usr_list(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_app_component component,
							pkgmgrinfo_app_list_cb app_func, void *user_data, uid_t uid);

/**
 * @fn	int pkgmgrinfo_appinfo_get_applist_for_amd(pkgmgrinfo_app_list_cb app_func, void *user_data);
 * @brief	This API gets list of installed applications from all packages with  minimum informaion.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_apps()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_appinfo_get_applist_for_amd(app_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_usr_applist_for_amd(pkgmgrinfo_app_list_cb app_func, uid_t uid, void *user_data);
int pkgmgrinfo_appinfo_get_applist_for_amd(pkgmgrinfo_app_list_cb app_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_get_installed_list(pkgmgrinfo_app_list_cb app_func, void *user_data);
 * @brief	This API gets list of installed applications from all packages.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_apps()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_appinfo_get_installed_list(app_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_installed_list(pkgmgrinfo_app_list_cb app_func, void *user_data);
int pkgmgrinfo_appinfo_get_usr_installed_list(pkgmgrinfo_app_list_cb app_func, uid_t uid, void *user_data);

/**
 * @fn int pkgmgrinfo_appinfo_get_disabled_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle)
 * @brief	This API creates the disabled application information handle from db
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	appid	pointer to appid
 * @param[out] handle		pointer to the application info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_disabled_app_type(const char *appid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_disabled_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype: %s\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_disabled_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle);
int pkgmgrinfo_appinfo_get_usr_disabled_appinfo(const char *appid, uid_t uid, pkgmgrinfo_appinfo_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_get_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle)
 * @brief	This API creates the application information handle from db
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	appid	pointer to appid
 * @param[out] handle		pointer to the application info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype: %s\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle);
int pkgmgrinfo_appinfo_get_usr_appinfo(const char *appid, uid_t uid, pkgmgrinfo_appinfo_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_get_appid(pkgmgrinfo_appinfo_h handle, char **appid)
 * @brief	This API gets the application ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] appid		pointer to hold appid
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_id(const char *appid)
{
	int ret = 0;
	char *app_id = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_appid(handle, &app_id);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app id: %s\n", app_id);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_appid(pkgmgrinfo_appinfo_h  handle, char **appid);

/**
 * @fn int pkgmgrinfo_appinfo_get_pkgname(pkgmgrinfo_appinfo_h handle, char **pkg_name)
 * @brief	This API gets the package name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] pkg_name		pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_pkgname(const char *appid)
{
	int ret = 0;
	char *pkgname = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_pkgname(handle, &pkgname);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("pkg name: %s\n", pkgname);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_pkgname(pkgmgrinfo_appinfo_h  handle, char **pkg_name);

/**
 * @fn int pkgmgrinfo_appinfo_get_pkgid(pkgmgrinfo_appinfo_h handle, char **pkgid)
 * @brief	This API gets the package id of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] pkgid		pointer to hold package id
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_pkgid(const char *appid)
{
	int ret = 0;
	char *pkgid = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("pkg id: %s\n", pkgid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_pkgid(pkgmgrinfo_appinfo_h  handle, char **pkgid);

/**
 * @fn int pkgmgrinfo_appinfo_get_pkgtype(pkgmgrinfo_appinfo_h handle, char **pkgtype)
 * @brief	This API gets the package type of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] pkgtype		pointer to hold package type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_pkgtype(const char *appid)
{
	int ret = 0;
	char *pkgtype = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_pkgtype(handle, &pkgtype);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", pkgtype);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_pkgtype(pkgmgrinfo_appinfo_h  handle, char **pkgtype);

/**
 * @fn int pkgmgrinfo_appinfo_get_exec(pkgmgrinfo_appinfo_h handle, char **exec)
 * @brief	This API gets the executable name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] exec		pointer to hold app exec name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_exec(const char *appid)
{
	int ret = 0;
	char *exec = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_exec(handle, &exec);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("exec name: %s\n", exec);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_exec(pkgmgrinfo_appinfo_h  handle, char **exec);

/**
 * @fn int pkgmgrinfo_appinfo_get_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the icon name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] icon		pointer to hold app icon name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_icon(const char *appid)
{
	int ret = 0;
	char *icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_icon(handle, &icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("icon name: %s\n", icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_label(pkgmgrinfo_appinfo_h handle, char **label)
 * @brief	This API gets the label of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] label		pointer to hold app label
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_label(const char *appid)
{
	int ret = 0;
	char *label = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_label(handle, &label);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("label : %s\n", label);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_label(pkgmgrinfo_appinfo_h  handle, char **label);

/**
 * @fn int pkgmgrinfo_appinfo_get_localed_label(const char *appid, const char *locale, char **label)
 * @brief	This API gets exactly matched label by given appid and locale
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	appid	pointer to appid
 * @param[in]	locale	pointer to locale
 * @param[out] label		pointer to hold app label
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_localed_label(const char *appid, const char *locale)
{
	int ret = 0;
	char *label = NULL;

	ret = pkgmgrinfo_appinfo_get_localed_label(appid, locale, &label);
	if (ret != PMINFO_R_OK)
		return -1;

	printf("localed label: %s\n", label);

	free(label);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_localed_label(const char *appid, const char *locale, char **label);
int pkgmgrinfo_appinfo_usr_get_localed_label(const char *appid, const char *locale, uid_t uid, char **label);

/**
 * @fn int pkgmgrinfo_appinfo_get_metadata_value(pkgmgrinfo_appinfo_h handle, const char *metadata_key, char **metadata_value)
 * @brief	This API gets metadata value by given metadata key
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to the application info handle
 * @param[in]	metadata_key	metadata key
 * @param[out] metadata_value		pointer to hold metadata value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @code
static int get_metadata_value(const char *appid, const char *metadata_key)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	char *metadata_value = NULL;

	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_appinfo_get_metadata_value(handle, metadata_key, &metadata_value);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}

	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_metadata_value(pkgmgrinfo_appinfo_h handle, const char *metadata_key, char **metadata_value);

/**
 * @fn int pkgmgrinfo_appinfo_get_component(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_component *component)
 * @brief	This API gets the component of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] component		pointer to hold app component
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_component(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_component component;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_component(handle, &component);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("component : %s\n", component);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_component(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_component *component);

/**
 * @fn int pkgmgrinfo_appinfo_get_apptype(pkgmgrinfo_appinfo_h handle, char **app_type)
 * @brief	This API gets the apptype of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] app_type		pointer to hold apptype
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *apptype = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &apptype);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype : %s\n", apptype);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_apptype(pkgmgrinfo_appinfo_h  handle, char **app_type);

/**
 * @fn int pkgmgrinfo_appinfo_get_operation(pkgmgrinfo_appcontrol_h  handle,
										int *operation_count, char ***operation)
 * @brief	This API gets the list of operation of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] operation_count		pointer to hold number of operations
 * @param[out] operation		pointer to hold list of operations
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_mime()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int oc = 0;
	int i = 0;
	char **operation;
	pkgmgrinfo_appinfo_get_operation(handle, &oc, &operation);
	for (i = 0; i < oc; i++) {
		if (strcmp(operation[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_operation(const char *appid, char *operation)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)operation);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_operation(pkgmgrinfo_appcontrol_h  handle,
										int *operation_count, char ***operation);

/**
 * @fn int pkgmgrinfo_appinfo_get_uri(pkgmgrinfo_appcontrol_h  handle,
										int *uri_count, char ***uri)
 * @brief	This API gets the list of uri of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] uri_count		pointer to hold number of uris
 * @param[out] uri		pointer to hold list of uris
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @see		pkgmgrinfo_appinfo_get_mime()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int uc = 0;
	int i = 0;
	char **uri;
	pkgmgrinfo_appinfo_get_uri(handle, &uc, &uri);
	for (i = 0; i < uc; i++) {
		if (strcmp(uri[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_uri(const char *appid, char *uri)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)uri);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_uri(pkgmgrinfo_appcontrol_h  handle,
										int *uri_count, char ***uri);

/**
 * @fn int pkgmgrinfo_appinfo_get_mime(pkgmgrinfo_appcontrol_h  handle,
										int *mime_count, char ***mime)
 * @brief	This API gets the list of mime of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] mime_count		pointer to hold number of mimes
 * @param[out] mime		pointer to hold list of mimes
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int mc = 0;
	int i = 0;
	char **mime;
	pkgmgrinfo_appinfo_get_operation(handle, &mc, &mime);
	for (i = 0; i < mc; i++) {
		if (strcmp(mime[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_mime(const char *appid, char *mime)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)mime);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_mime(pkgmgrinfo_appcontrol_h  handle,
										int *mime_count, char ***mime);

/**
 * @fn int pkgmgrinfo_appinfo_get_subapp(pkgmgrinfo_appcontrol_h  handle,
										int *subapp_count, char ***subapp)
 * @brief	This API gets the list of subapp of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] subapp_count		pointer to hold number of subapp
 * @param[out] subapp		pointer to hold list of subapp
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int sc = 0;
	int i = 0;
	char **subapp = NULL;
	pkgmgrinfo_appinfo_get_subapp(handle, &sc, &subapp);
	for (i = 0; i < sc; i++) {
		if (strcmp(subapp[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_subapp(const char *appid, char *subapp)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)subapp);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_subapp(pkgmgrinfo_appcontrol_h  handle,
						int *subapp_count, char ***subapp);

/**
 * @fn int pkgmgrinfo_appinfo_get_notification_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the notification icon of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] path		pointer to hold notification icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_notification_icon(const char *appid)
{
	int ret = 0;
	char *notification_icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_notification_icon(handle, &notification_icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("notification icon : %s\n", notification_icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_notification_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_setting_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the setting icon of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] path		pointer to hold setting icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_setting_icon(const char *appid)
{
	int ret = 0;
	char *setting_icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_setting_icon(handle, &setting_icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("setting icon : %s\n", setting_icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_setting_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_recent_image_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_recentimage *type)
 * @brief	This API gets the type of recent image on app-tray
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] type		pointer to hold image type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_recent_image_type(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_recentimage type;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_recent_image_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("recent image type: %d\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_recent_image_type(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_recentimage *type);


/**
 * @fn int pkgmgrinfo_appinfo_get_preview_image(pkgmgrinfo_appinfo_h  handle, char **preview_img)
 * @brief	This API gets the preview image of application
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] preview_img		pointer to hold preview image path
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_previewimage(const char *appid)
{
	int ret = 0;
	char *preview = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_preview_image(handle, &preview);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("preview image path : %s\n", preview);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_preview_image(pkgmgrinfo_appinfo_h  handle, char **preview_img);


/**
 * @fn int pkgmgrinfo_appinfo_get_permission_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_permission_type *permission)
 * @brief	This API gets the package permission type of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] permission		pointer to hold package permission
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_permission(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_permission_type permission = 0;
	pkgmgrinfo_appinfo_h handle;

	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_permission_type(handle, &permission);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("permission type: %d\n", permission);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_permission_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_permission_type *permission);

/**
 * @fn int pkgmgrinfo_appinfo_get_component_type(pkgmgrinfo_appinfo_h handle, char **component_type)
 * @brief	This API gets the component_type
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] component_type		pointer to hold component_type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_component_type(const char *appid)
{
	int ret = 0;
	char *component_type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_component_type(handle, &component_type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("component_type: %s\n", component_type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_component_type(pkgmgrinfo_appinfo_h  handle, char **component_type);

/**
 * @fn int pkgmgrinfo_appinfo_get_hwacceleration(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_hwacceleration *hwacceleration)
 * @brief	This API gets the application 'hwacceleration' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] hwacceleration		pointer to hold package hwacceleration value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_hwacceleration(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_hwacceleration hwacceleration;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_hwacceleration(handle, &hwacceleration);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app hwacceleration: %d\n", hwacceleration);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_hwacceleration(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_hwacceleration *hwacceleration);

/**
 * @fn int pkgmgrinfo_appinfo_get_screenreader(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_screenreader *screenreader)
 * @brief	This API gets the application 'screenreader' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] screenreader		pointer to hold package accessibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_screenreader(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_screenreader screenreader = PMINFO_USE_SYSTEM_SETTING;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_screenreader(handle, &screenreader);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app screenreader: %d\n", screenreader);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_screenreader(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_screenreader *screenreader);

/**
 * @fn int pkgmgrinfo_appinfo_get_effectimage(pkgmgrinfo_appinfo_h  handle, char **portrait_img, char **landscape_img)
 * @brief	This API gets the application's landscape & portrait effect images
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]  portrait_img contains portrait mode effect image
 * @param[out]  landscape_img contains landscape mode effect image
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_effectimages(const char *appid)
{
	int ret = 0;
	char *portraitimg = NULL;
	char *landscapeimg = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_effectimage(handle, &portraitimg, &landscapeimg);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app effect image portrait: %s, app effect image landscape : %s\n", portraitimg, landscapeimg);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_effectimage(pkgmgrinfo_appinfo_h  handle, char **portrait_img, char **landscape_img);

/**
 * @fn int pkgmgrinfo_appinfo_get_effectimage_type(pkgmgrinfo_appinfo_h  handle, char **effectimg_type)
 * @brief	This API gets the application's effect image type
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]  effectimg_type contains effect image type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_effectimage_type(const char *appid)
{
	int ret = 0;
	char *effectimg_type = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_effectimage_type(handle, &effectimg_type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app effect image type: %s\n", effectimg_type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_effectimage_type(pkgmgrinfo_appinfo_h handle, char **effectimg_type);

/**
 * @fn int pkgmgrinfo_appinfo_get_submode_mainid(pkgmgrinfo_appinfo_h handle, char **submode_mainid)
 * @brief	This API gets the submode_mainid of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] submode_mainid		pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_submode_mainid(const char *appid)
{
	int ret = 0;
	char *submode_mainid = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_submode_mainid(handle, &submode_mainid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("submode_mainid: %s\n", submode_mainid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_submode_mainid(pkgmgrinfo_appinfo_h  handle, char **submode_mainid);

/**
 * @fn int pkgmgrinfo_appinfo_get_datacontrol_info(const char *providerid, const char *type, char **appid, char **access);
 * @brief	This API gets the datacontrol info
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] providerid		pointer to the providerid of dataconltrol.
 * @param[in] type			pointer to the type of dataconltrol.
 * @param[out] appid			pointer to hold appid, need to free after using
 * @param[out] access			pointer to hold access, need to free after using
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @endcode
 */
int pkgmgrinfo_appinfo_get_datacontrol_info(const char *providerid, const char *type, char **appid, char **access);
int pkgmgrinfo_appinfo_usr_get_datacontrol_info(const char *providerid, const char *type, uid_t uid, char **appid, char **access);

/**
 * @fn int pkgmgrinfo_appinfo_get_datacontrol_appid(const char *providerid, char **appid);
 * @brief	This API gets the appid of datacontrol
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] providerid		pointer to the providerid of dataconltrol.
 * @param[out] appid			pointer to hold appid, need to free after using
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @endcode
 */
int pkgmgrinfo_appinfo_get_datacontrol_appid(const char *providerid, char **appid);
int pkgmgrinfo_appinfo_usr_get_datacontrol_appid(const char *providerid, uid_t uid, char **appid);

/**
 * @fn int pkgmgrinfo_appinfo_get_alias_appid(pkgmgrinfo_appinfo_h  handle, char **alias_appid)
 * @brief	This API gets the alias_appid of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] alias_appid		pointer to hold app alias_appid
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_alias_appid(const char *appid)
{
	int ret = 0;
	char *alias_appid= 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_alias_appid(handle, &alias_appid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("alias_appid: %s\n", alias_appid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_alias_appid(pkgmgrinfo_appinfo_h handle, char **alias_appid);

/**
 * @fn int pkgmgrinfo_appinfo_get_effective_appid(pkgmgrinfo_appinfo_h  handle, char **effective_appid)
 * @brief	This API gets the effective_appid of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] effective_appid		pointer to hold app effective_appid
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_effective_appid(const char *appid)
{
	int ret = 0;
	char *effective_appid= 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_effective_appid(handle, &effective_appid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("effective_appid: %s\n", effective_appid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_effective_appid(pkgmgrinfo_appinfo_h handle, char **effective_appid);

/**
 * @fn int pkgmgrinfo_appinfo_get_tep_name(pkgmgrinfo_appinfo_h handle, char **tep_name)
 * @brief	This API gets tep(tizen expansion package) file name associated with the package which contain given application
 *
 * @par	This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle 		pointer to the appinfo handle.
 * @param[out] tep_name 	pointer to hold tep name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK success
 * @retval	PMINFO_R_EINVAL invalid argument
 * @retval	PMINFO_R_ERROR  internal error
 * @pre	pkgmgrinfo_appinfo_get_appinfo()
 * @post 		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see	pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_tep_name(const char *appid)
{
	int ret = 0;
	char *tep_name = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_tep_name(handle, &tep_name);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("TEP name is: %s\n", tep_name);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_tep_name(pkgmgrinfo_appinfo_h handle, char **tep_name);

/**
 * @fn int pkgmgrinfo_appinfo_get_zip_mount_file(pkgmgrinfo_appinfo_h handle, char **zip_mount_file)
 * @brief	This API gets zip mount file name associated with the package which contain given application
 *          If package is not "mount-installed", zip_mount_file is left as NULL pointer.
 *
 * @par	This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle 		pointer to the appinfo handle.
 * @param[out] zip_mount_file 	pointer to hold zip mount file name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK success
 * @retval	PMINFO_R_EINVAL invalid argument
 * @retval	PMINFO_R_ERROR  internal error
 * @pre	pkgmgrinfo_appinfo_get_appinfo()
 * @post 		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see	pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_zip_mount_file(const char *appid)
{
	int ret = 0;
	char *zip_mount_file = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_zip_mount_file(handle, &zip_mount_file);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("Mount file name is: %s\n", zip_mount_file);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_zip_mount_file(pkgmgrinfo_appinfo_h handle, char **zip_mount_file);

/**
 * @fn int pkgmgrinfo_appinfo_get_root_path(pkgmgrinfo_appinfo_h handle, char **path)
 * @brief	This API gets the root path of application
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to appinfo handle
 * @param[out] path		pointer to hold root path of application
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_root_path(const char *appid)
{
	int ret = 0;
	char *path = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_appinfo_get_root_path(handle, &path);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("path : %s\n", path);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_root_path(pkgmgrinfo_appinfo_h handle, char **root_path);

/**
 * @fn int pkgmgrinfo_appinfo_get_api_version(pkgmgrinfo_appinfo_h handle, char **api_version)
 * @brief	This API gets the application api_version from the application ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to appinfo handle
 * @param[out] api_version		pointer to hold application api_version
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_api_version(const char *appid)
{
	int ret = 0;
	char *api_version = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_api_version(handle, &api_version);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app api_version: %s\n", api_version);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_api_version(pkgmgrinfo_appinfo_h handle, char **api_version);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_permission(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_permission_list_cb permission_func, void *user_data);
 * @brief	This API gets the list of permission for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	permission_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int permission_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_permission(const char *appid, char *permission)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_permission(handle, permission_func, (void *)permission);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_permission(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_permission_list_cb permission_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_category(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_category_list_cb category_func, void *user_data);
 * @brief	This API gets the list of category for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	category_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int category_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_category(const char *appid, char *category)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_category(handle, category_func, (void *)category);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_category(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_category_list_cb category_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_metadata(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_metadata_list_cb metadata_func, void *user_data);
 * @brief	This API gets the list of metadata for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	metadata_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int metadata_func(const char *key, const char *value, void *user_data)
{
	if (strcmp(key, (char *)user_data) == 0) {
		printf("Value is %s\n", value);
		return -1;
	}
	else
		return 0;
}

static int list_metadata(const char *appid, char *key)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_metadata(handle, metadata_func, (void *)key);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_metadata(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_metadata_list_cb metadata_func, void *user_data);


/**
 * @fn	int pkgmgrinfo_appinfo_foreach_appcontrol(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_control_list_cb appcontrol_func, void *user_data);
 * @fn	int pkgmgrinfo_usr_appinfo_foreach_appcontrol(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_control_list_cb appcontrol_func, void *user_data, uid_t uid);
 * @brief	This API gets the list of app-control for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	appcontrol_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @param[in]	uid	the addressee user id of the instruction
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int oc = 0;
	int i = 0;
	char **operation;
	pkgmgrinfo_appinfo_get_operation(handle, &oc, &operation);
	for (i = 0; i < oc; i++) {
		if (strcmp(operation[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_operation(const char *appid, char *operation)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)operation);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_appcontrol(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_control_list_cb appcontrol_func, void *user_data);

/**
 * @brief
 */
int pkgmgrinfo_appinfo_foreach_background_category(pkgmgrinfo_appinfo_h handle,
		pkgmgrinfo_app_background_category_list_cb category_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_splash_screen(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_splash_screen_list_cb splash_screen_func, void *user_data);
 * @brief	This API gets the list of splashscreen for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	splash_screen_func		callback function for list
 * @param[in]	user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
 */
int pkgmgrinfo_appinfo_foreach_splash_screen(pkgmgrinfo_appinfo_h handle,
		pkgmgrinfo_app_splash_screen_list_cb splash_screen_func, void *user_data);

/**
 * @fn int pkgmgrinfo_appinfo_is_nodisplay(pkgmgrinfo_appinfo_h handle, bool *nodisplay)
 * @brief	This API gets the application 'nodisplay' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] nodisplay		pointer to hold package nodisplay value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_nodisplay(const char *appid)
{
	int ret = 0;
	bool nodisplay;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_nodisplay(handle, &nodisplay);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app nodisplay: %d\n", nodisplay);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_nodisplay(pkgmgrinfo_appinfo_h  handle, bool *nodisplay);

/**
 * @fn int pkgmgrinfo_appinfo_is_multiple(pkgmgrinfo_appinfo_h handle, bool *multiple)
 * @brief	This API gets the application 'multiple' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] multiple		pointer to hold package multiple value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_multiple(const char *appid)
{
	int ret = 0;
	bool multiple;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_multiple(handle, &multiple);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app multiple: %d\n", multiple);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_multiple(pkgmgrinfo_appinfo_h  handle, bool *multiple);

/**
 * @fn int pkgmgrinfo_appinfo_is_indicator_display_allowed(pkgmgrinfo_appinfo_h handle, bool *indicator_disp)
 * @brief	This API gets the application 'indicatordisplay' value. If true, indicator will be displayed during
 *		application launching effect. If fales, indicator will be hidden during application launching effect
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]  indicator_disp contains indicator display status for application launching effect
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_indicator_display(const char *appid)
{
	int ret = 0;
	bool indicator_disp;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_indicator_display_allowed(handle, &indicator_disp);
	if (ret != PMINFO_R_OK){
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app indicator disp : %d\n", indicator_disp);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_indicator_display_allowed(pkgmgrinfo_appinfo_h handle, bool *indicator_disp);

/**
 * @fn int pkgmgrinfo_appinfo_is_taskmanage(pkgmgrinfo_appinfo_h handle, bool *taskmanage)
 * @brief	This API gets the application 'taskmanage' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] taskmanage		pointer to hold package taskmanage value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_taskmanage(const char *appid)
{
	int ret = 0;
	bool taskmanage;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_taskmanage(handle, &taskmanage);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app taskmanage: %d\n", taskmanage);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_taskmanage(pkgmgrinfo_appinfo_h  handle, bool *taskmanage);

/**
 * @fn int pkgmgrinfo_appinfo_is_enabled(pkgmgrinfo_appinfo_h handle, bool *enabled)
 * @brief	This API gets the application 'taskmanage' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] enabled		pointer to hold package enabled value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_enabled(const char *appid)
{
	int ret = 0;
	bool enabled;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_taskmanage(handle, &enabled);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app enabled: %d\n", enabled);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_enabled(pkgmgrinfo_appinfo_h  handle, bool *enabled);

/**
 * @fn int pkgmgrinfo_appinfo_is_onboot(pkgmgrinfo_appinfo_h handle, bool *onboot)
 * @brief	This API gets the application 'onboot' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] onboot		pointer to hold package onboot value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_onboot(const char *appid)
{
	int ret = 0;
	bool onboot;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_onboot(handle, &onboot);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app onboot: %d\n", onboot);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_onboot(pkgmgrinfo_appinfo_h  handle, bool *onboot);

/**
 * @fn int pkgmgrinfo_appinfo_is_autorestart(pkgmgrinfo_appinfo_h handle, bool *autorestart)
 * @brief	This API gets the application 'autorestart' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] autorestart		pointer to hold package autorestart value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_autorestart(const char *appid)
{
	int ret = 0;
	bool autorestart;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_autorestart(handle, &autorestart);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app autorestart: %d\n", autorestart);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_autorestart(pkgmgrinfo_appinfo_h  handle, bool *autorestart);

/**
 * @fn int pkgmgrinfo_appinfo_is_mainapp(pkgmgrinfo_appinfo_h  handle, bool *mainapp)
 * @brief	This API gets the value for given application is main app or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] mainapp		pointer to hold package mainapp is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_mainapp(const char *appid)
{
	int ret = 0;
	bool mainapp;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_mainapp(handle, &mainapp);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("mainapp: %d\n", mainapp);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_mainapp(pkgmgrinfo_appinfo_h  handle, bool *mainapp);


/**
 * @fn int pkgmgrinfo_appinfo_is_preload(pkgmgrinfo_appinfo_h handle, bool *preload)
 * @brief	This API gets the value for given application is preload or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] preload		pointer to hold preload is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_preload(const char *appid)
{
	int ret = 0;
	bool preload = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_preload(handle, &preload);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("preload: %d\n", preload);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_preload(pkgmgrinfo_appinfo_h handle, bool *preload);

/**
 * @fn int pkgmgrinfo_appinfo_is_submode(pkgmgrinfo_appinfo_h handle, bool *submode)
 * @brief	This API gets the value for given application is submode or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] submode		pointer to hold submode is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_submode(const char *appid)
{
	int ret = 0;
	bool submode = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_submode(handle, &submode);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("submode: %d\n", submode);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_submode(pkgmgrinfo_appinfo_h handle, bool *submode);

/**
 * @fn int int pkgmgrinfo_appinfo_is_process_pool(pkgmgrinfo_appinfo_h handle, bool *process_pool)
 * @brief	This API gets the value for given application is process_pool or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] process_pool		pointer to hold process_pool is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_process_pool(const char *appid)
{
	int ret = 0;
	bool process_pool = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_process_pool(handle, &process_pool);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("process_pool: %d\n", process_pool);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_process_pool(pkgmgrinfo_appinfo_h handle, bool *process_pool);

/**
 * @fn int pkgmgrinfo_appinfo_get_installed_storage_location(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_installed_storage *storage)
 * @brief	This API gets the installed storage location of the application
 *
 * @par	This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle 		pointer to the application info handle.
 * @param[out] app_type 	pointer to hold installed storage location
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK success
 * @retval	PMINFO_R_EINVAL invalid argument
 * @retval	PMINFO_R_ERROR  internal error
 * @pre	pkgmgrinfo_appinfo_get_appinfo()
 * @post 		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see	pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_installed_location(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_installed_storage storage;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_installed_storage_location(handle, &storage);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("Installed storage location : %d\n", storage);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_installed_storage_location(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_installed_storage *storage);


/**
 * @fn int pkgmgrinfo_appinfo_is_category_exist(pkgmgrinfo_appinfo_h handle, const char *category, bool *exist)
 * @brief	This API checks if the application has the given category
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to the application info handle
 * @param[in]	category	category
 * @param[out] exist		value Gets whether the application has the given category
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int is_category_exist(const char *appid, const char *category)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	bool exist = false;

	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_appinfo_is_category_exist(handle, category, &exist);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}

	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_category_exist(pkgmgrinfo_appinfo_h handle, const char *category, bool *exist);

/**
 * @fn int pkgmgrinfo_appinfo_is_ui_gadget(pkgmgrinfo_appinfo_h handle, bool *ui_gadget)
 * @brief	This API gets the application 'ui_gadget' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]	ui_gadget	pointer to hold package ui_gadget value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
static int get_app_ui_gadget(const char *appid)
{
	int ret = 0;
	bool ui_gadget;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_ui_gadget(handle, &ui_gadget);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app ui_gadget: %d\n", ui_gadget);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_ui_gadget(pkgmgrinfo_appinfo_h handle, bool *ui_gadget);

/**
 * @fn int pkgmgrinfo_appinfo_is_support_disable(pkgmgrinfo_appinfo_h handle, bool *support_disable)
 * @brief	This API gets the application 'support_disable' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]	support_disable	pointer to hold package support_disable value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
static int get_app_support_disable(const char *appid)
{
	int ret = 0;
	bool support_disable;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_support_disable(handle, &support_disable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app support_disable: %d\n", support_disable);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_support_disable(pkgmgrinfo_appinfo_h handle, bool *support_disable);

/**
 * @fn int pkgmgrinfo_appinfo_is_disabled(pkgmgrinfo_appinfo_h handle, bool *disabled)
 * @brief	This API gets the application 'is_disable' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]	disabled	pointer to hold application is_disabled value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
static int get_app_is_disable(const char *appid)
{
	int ret = 0;
	bool is_disable;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_disabled(handle, &is_disable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app is_disable: %d\n", is_disable);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_disabled(pkgmgrinfo_appinfo_h handle, bool *disabled);

/**
 * @fn int pkgmgrinfo_appinfo_is_global(pkgmgrinfo_appinfo_h handle, bool *global)
 * @brief	This API gets whethere the given application is global application or user application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[in]	global	pointer to hold application global value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 static int get_app_is_global(const char *appid)
 {
	 int ret = 0;
	 bool global;
	 pkgmgrinfo_appinfo_h handle = NULL;
	 ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	 if (ret != PMINFO_R_OK)
		 return -1;
	 ret = pkgmgrinfo_appinfo_is_global(handle, &global);
	 if (ret != PMINFO_R_OK) {
		 pkgmgrinfo_appinfo_destroy_appinfo(handle);
		 return -1;
	 }
	 printf("app is_global: %d\n", global);
	 pkgmgrinfo_appinfo_destroy_appinfo(handle);
	 return 0;
 }
  * @endcode
  */
int pkgmgrinfo_appinfo_is_global(pkgmgrinfo_appinfo_h handle, bool *global);

/**
 * @fn int pkgmgrinfo_appinfo_get_splash_screen_display(pkgmgrinfo_appinfo_h handle, bool *splash_screen_display)
 * @brief	This API gets the application 'splash_screen_display' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle		pointer to application info handle
 * @param[out]	splash_screen_display	pointer to hold package splash_screen_display value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 */
int pkgmgrinfo_appinfo_get_splash_screen_display(pkgmgrinfo_appinfo_h handle, bool *splash_screen_display);

/**
 * @fn int pkgmgrinfo_appinfo_destroy_appinfo(pkgmgrinfo_appinfo_h handle)
 * @brief	This API destroys the application information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		None
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype: %s\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_destroy_appinfo(pkgmgrinfo_appinfo_h  handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_create(pkgmgrinfo_appinfo_filter_h *handle)
 * @brief	This API creates the application information filter handle from db.  All filter properties will be ANDed.
 The query will search the entire application information collected from the manifest file of all the installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the application info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_create(pkgmgrinfo_appinfo_filter_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_destroy(pkgmgrinfo_appinfo_filter_h handle)
 * @brief	This API destroys the application information filter handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		None
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_destroy(pkgmgrinfo_appinfo_filter_h handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_bool(pkgmgrinfo_appinfo_filter_h handle, const char *property, const bool value)
 * @brief	This API adds a boolean filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		boolean property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_taskmanageable_app_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_bool(handle, PMINFO_APPINFO_PROP_APP_TASKMANAGE, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of taskmanageable apps: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_bool(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const bool value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_int(pkgmgrinfo_appinfo_filter_h handle, const char *property, const int value)
 * @brief	This API adds an integer filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		integer property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_taskmanageable_app_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_bool(handle, PMINFO_APPINFO_PROP_APP_XXX, 10);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of apps: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_int(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const int value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_string(pkgmgrinfo_appinfo_filter_h handle, const char *property, const char *value)
 * @brief	This API adds a string filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		string property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_string(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const char *value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_foreach_appinfo(pkgmgrinfo_appinfo_filter_h handle, pkgmgrinfo_app_list_cb app_cb, void *user_data)
 * @brief	This API executes the user supplied callback function for each application that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] app_cb		callback function.
 * @param[in] user_data		user data to be passed to the callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_capp_list()
{
	int ret = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_foreach_appinfo(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_foreach_appinfo(pkgmgrinfo_appinfo_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data);
int pkgmgrinfo_appinfo_usr_filter_foreach_appinfo(pkgmgrinfo_appinfo_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data, uid_t uid);

/**
 * @fn int pkgmgrinfo_appinfo_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count)
 * @fn int pkgmgrinfo_appinfo_usr_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count, uid_t uid)
 * @brief	This API counts the application that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] count		pointer to store count value
 * @param[in]	uid	the addressee user id of the instruction
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count);
int pkgmgrinfo_appinfo_usr_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count, uid_t uid);
/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_create(pkgmgrinfo_appinfo_metadata_filter_h *handle)
 * @brief	This API creates the application's metadata  information filter handle from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the application metadata info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_create(pkgmgrinfo_appinfo_metadata_filter_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_destroy(pkgmgrinfo_appinfo_metadata_filter_h handle)
 * @brief	This API destroys the application's metadata  information filter handle.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		None
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_destroy(pkgmgrinfo_appinfo_metadata_filter_h handle);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_add(pkgmgrinfo_appinfo_metadata_filter_h handle, const char *key, const char *value)
 * @brief	This API adds filter condition for the query API.  The query will search the entire application metadata  information collected from
 * the manifest file of all the installed packages. You can specify value as NULL to search based on key only.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @param[in] key			pointer to metadata key
 * @param[in] value			pointer to metadata value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		pkgmgrinfo_appinfo_metadata_filter_foreach(), pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_add(pkgmgrinfo_appinfo_metadata_filter_h handle,
		const char *key, const char *value);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle, pkgmgrinfo_app_list_cb app_cb, void *user_data)
 * @fn int pkgmgrinfo_appinfo_usr_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle, pkgmgrinfo_app_list_cb app_cb, void *user_data, uid_t uid)
 * @brief	This API executes the filter query. The query will search the entire application metadata  information collected from
 * the manifest file of all the installed packages. For each application returned by the query, the callback will be called. If callback returns
 * negative value, no more callbacks will be called and API will return.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @param[in] app_cb		function pointer to callback
 * @param[in] user_data		pointer to user data
 * @param[in]	uid	the addressee user id of the instruction
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data);
int pkgmgrinfo_appinfo_usr_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data, uid_t uid);
/**
 * @fn int pkgmgrinfo_pkginfo_create_certinfo(pkgmgrinfo_certinfo_h *handle)
 * @brief	This API creates the package cert information handle to get data from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_get_cert_value()
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_create_certinfo(pkgmgrinfo_certinfo_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_load_certinfo(const char *pkgid, pkgmgrinfo_certinfo_h handle)
 * @brief	This API loads the package cert information handle with data from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_get_cert_value()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_load_certinfo(const char *pkgid, pkgmgrinfo_certinfo_h handle, uid_t uid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_cert_value(pkgmgrinfo_certinfo_h handle, pkgmgrinfo_cert_type cert_type, const char **cert_value)
 * @brief	This API gets the package cert information from the handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @param[in] cert_type		certificate type
 * @param[out] cert_value	pointer to hold certificate value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_cert_value(pkgmgrinfo_certinfo_h handle, pkgmgrinfo_cert_type cert_type, const char **cert_value);

/**
 * @fn int pkgmgrinfo_pkginfo_destroy_certinfo(pkgmgrinfo_certinfo_h handle)
 * @brief	This API destroys the package cert information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_destroy_certinfo(pkgmgrinfo_certinfo_h handle);

/**
 * @fn int pkgmgrinfo_delete_certinfo(const char *pkgid)
 * @brief	This API deletes the package cert information from DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
static int delete_cert_info(const char *pkgid)
{
	int ret = 0;
	ret = pkgmgrinfo_delete_certinfo(pkgid);
	if (ret != PMINFO_R_OK)
		return -1;
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_delete_certinfo(const char *pkgid);
 int pkgmgrinfo_delete_usr_certinfo(const char *pkgid, uid_t uid);

/**
 * @fn int pkgmgrinfo_create_certinfo_set_handle(pkgmgrinfo_instcertinfo_h *handle)
 * @brief	This API creates the package cert information handle to set data in db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_set_cert_value()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_create_certinfo_set_handle(pkgmgrinfo_instcertinfo_h *handle);

/**
 * @fn int pkgmgrinfo_set_cert_value(pkgmgrinfo_instcertinfo_h handle, pkgmgrinfo_instcert_type cert_type, char *cert_value)
 * @brief	This API sets the package cert information in the handle.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @param[in] cert_type		certificate type.
 * @param[in] cert_value	certificate value.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_cert_value(pkgmgrinfo_instcertinfo_h handle, pkgmgrinfo_instcert_type cert_type, char *cert_value);

/**
 * @fn int pkgmgrinfo_save_certinfo(const char *pkgid, pkgmgrinfo_instcertinfo_h handle)
 * @brief	This API saves the package cert information in the DB.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_save_certinfo(const char *pkgid, pkgmgrinfo_instcertinfo_h handle, uid_t uid);

/**
 * @fn int pkgmgrinfo_destroy_certinfo_set_handle(pkgmgrinfo_instcertinfo_h handle)
 * @brief	This API destroys the package cert information handle freeing up all the resources.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		None
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_destroy_certinfo_set_handle(pkgmgrinfo_instcertinfo_h handle);

/**
 * @fn int pkgmgrinfo_datacontrol_get_info(const char *providerid, const char * type, char **appid, char **access)
 * @brief	This API gets the datacontrol info
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] providerid		pointer to the providerid of dataconltrol.
 * @param[in] type			pointer to the type of dataconltrol.
 * @param[out] appid			pointer to hold appid, need to free after using
 * @param[out] access			pointer to hold access, need to free after using
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @endcode
 */
int pkgmgrinfo_datacontrol_get_info(const char *providerid, const char * type, char **appid, char **access);

/**
 * @fn int pkgmgrinfo_appinfo_is_guestmode_appstatus(pkgmgrinfo_appinfo_h handle, bool *status)
 * @brief	This API gets the application 'guest mode visibility' value from the DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] status		pointer to hold app guest mode visibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_guestmode_visibility(const char *appid)
{
	int ret = 0;
	bool status;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_guestmode_visibility(handle, &status);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app guest mode visibility: %d\n", status);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_appinfo_is_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool *status);

/**
 * @fn int pkgmgrinfo_appinfo_set_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool status)
 * @brief	This API sets the application 'guest mode visibility' value in the DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] status	app guest mode visibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int set_app_guestmode_visibility(const char *appid, bool value)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_set_guestmode_visibility(handle, value);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_appinfo_set_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool status);
 int pkgmgrinfo_appinfo_set_usr_guestmode_visibility(pkgmgrinfo_appinfo_h handle, uid_t uid, bool status);

/**
* @fn int pkgmgrinfo_pkginfo_set_installed_storage(const char *pkgid, INSTALL_LOCATION location)
* @brief	 This API sets the package 'installed_storage' value in db
*
* @par 	 This API is for package-manager client application
* @par Sync (or) Async : Synchronous API
*
* @param[in] pkgid 	 pointer to the package ID.
* @param[in] location  package install location
* @return  0 if success, error code(<0) if fail
* @retval  PMINFO_R_OK success
* @retval  PMINFO_R_EINVAL	 invalid argument
* @retval  PMINFO_R_ERROR internal error
* @code
static int set_app_installed_storage(const char *appid, INSTALL_LOCATION location)
{
	int ret = 0;

	ret = pkgmgrinfo_pkginfo_set_installed_storage(handle, INSTALL_EXTERNAL);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
* @endcode
*/
 int pkgmgrinfo_pkginfo_set_installed_storage(const char *pkgid, INSTALL_LOCATION location);
 int pkgmgrinfo_pkginfo_set_usr_installed_storage(const char * pkgid, INSTALL_LOCATION location, uid_t uid);

/**
 * @pkgmgrinfo client API
**/

/**
 * @brief listening status type in pkgmgrinfo.
 */
#define PMINFO_CLIENT_STATUS_ALL						0x00
#define PMINFO_CLIENT_STATUS_INSTALL					0x01
#define PMINFO_CLIENT_STATUS_UNINSTALL					0x02
#define PMINFO_CLIENT_STATUS_UPGRADE					0x04
#define PMINFO_CLIENT_STATUS_MOVE						0x08
#define PMINFO_CLIENT_STATUS_CLEAR_DATA					0x10
#define PMINFO_CLIENT_STATUS_INSTALL_PROGRESS			0x20

/**
 * @brief	This APIs provides pkgmgrinfo client listener
 */
pkgmgrinfo_client *pkgmgrinfo_client_new(pkgmgrinfo_client_type ctype);
int pkgmgrinfo_client_set_status_type(pkgmgrinfo_client *pc, int status_type);
int pkgmgrinfo_client_listen_status(pkgmgrinfo_client *pc, pkgmgrinfo_handler event_cb, void *data);
int pkgmgrinfo_client_free(pkgmgrinfo_client *pc);
int pkgmgrinfo_client_request_enable_external_pkg(char *pkgid);

/**
 * @brief	TEMP
 */


int pkgmgrinfo_pkginfo_get_usr_list_full(pkgmgrinfo_pkg_list_cb pkg_list_cb,
		int flag, void *user_data, uid_t uid);
int pkgmgrinfo_pkginfo_get_list_full(pkgmgrinfo_pkg_list_cb pkg_list_cb,
		int flag, void *user_data);
int pkgmgrinfo_appinfo_get_usr_installed_list_full(
		pkgmgrinfo_app_list_cb app_func, uid_t uid, int flag,
		void *user_data);
int pkgmgrinfo_appinfo_get_installed_list_full(
		pkgmgrinfo_app_list_cb app_func, int flag, void *user_data);

/**
 * @pkgmgrinfo client API end
**/


/** @} */
#ifdef __cplusplus
}
#endif
#endif				/* __PKG_INFO_H__ */
/**
 * @}
 * @}
 */

