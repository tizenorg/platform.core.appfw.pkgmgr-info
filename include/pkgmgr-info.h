/*
 * pkgmgr-info
 *
 * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
 *
 * Contact: Jayoun Lee <airjany@samsung.com>, Sewook Park <sewook7.park@samsung.com>,
 * Jaeho Lee <jaeho81.lee@samsung.com>, Shobhit Srivastava <shobhit.s@samsung.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */





/**
 * @file		pkgmgr-info.h
 * @author		Sewook Park <sewook7.park@samsung.com>
 * @author		Shobhit Srivastava <shobhit.s@samsung.com>
 * @version		0.1
 * @brief		This file declares API of pkgmgr-info library
 *
 * @addtogroup		APPLICATION_FRAMEWORK
 * @{
 *
 * @defgroup		PackageManagerInfo
 * @section		Header Header file to include:
 * @code
 * #include		<pkgmgr-info.h>
 * @endcode
 *
 * @}
 */

#ifndef __PKG_INFO_H__
#define __PKG_INFO_H__

#include <errno.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif


/**
 * @mainpage
 *
 * This is package information library
 *
 * Package Information Library is used to get package related information.\n
 * It uses the package manifest information database to get any package related information\n
 * It also provides API to set information in the package info database\n
 *
 */

/**
 * @file	pkgmgr-info.h
 * @brief	Package Information Library Header File
 *
 * Generated by    Sewook Park <sewook7.park@samsung.com>
 */


/**
 * @brief A handle to insert certificate information
 */
typedef void* pkgmgrinfo_instcertinfo_h;

/**
 * @brief Certificate Types to be used for setting information
 */
typedef enum {
	PMINFO_SET_AUTHOR_ROOT_CERT = 0,		/**< Author Root Certificate*/
	PMINFO_SET_AUTHOR_INTERMEDIATE_CERT = 1,		/**< Author Intermediate Certificate*/
	PMINFO_SET_AUTHOR_SIGNER_CERT = 2,		/**< Author Signer Certificate*/
	PMINFO_SET_DISTRIBUTOR_ROOT_CERT = 3,		/**< Distributor Root Certificate*/
	PMINFO_SET_DISTRIBUTOR_INTERMEDIATE_CERT = 4,		/**< Distributor Intermediate Certificate*/
	PMINFO_SET_DISTRIBUTOR_SIGNER_CERT = 5,		/**< Distributor Signer Certificate*/
	PMINFO_SET_DISTRIBUTOR2_ROOT_CERT = 6,		/**< End Entity Root Certificate*/
	PMINFO_SET_DISTRIBUTOR2_INTERMEDIATE_CERT = 7,		/**< End Entity Intermediate Certificate*/
	PMINFO_SET_DISTRIBUTOR2_SIGNER_CERT = 8,		/**< End Entity Signer Certificate*/
}pkgmgrinfo_instcert_type;

typedef enum {
	PMINFO_CERT_COMPARE_MATCH,
	PMINFO_CERT_COMPARE_MISMATCH,
	PMINFO_CERT_COMPARE_LHS_NO_CERT,
	PMINFO_CERT_COMPARE_RHS_NO_CERT,
	PMINFO_CERT_COMPARE_BOTH_NO_CERT,
	PMINFO_CERT_COMPARE_ERROR,
} pkgmgrinfo_cert_compare_result_type_e;

/**
 * @brief API return values
 */
enum {
	PMINFO_R_EINVAL = -2,		/**< Invalid argument */
	PMINFO_R_ERROR = -1,		/**< General error */
	PMINFO_R_OK = 0			/**< General success */
};

/**
 * @brief Value to be used when filtering based on install location
 */
#define	PMINFO_PKGINFO_INSTALL_LOCATION_AUTO		"LOCATION_AUTO"

/**
 * @brief Value to be used when filtering based on install location
 */
#define	PMINFO_PKGINFO_INSTALL_LOCATION_INTERNAL	"LOCATION_INTERNAL"

/**
 * @brief Value to be used when filtering based on install location
 */
#define	PMINFO_PKGINFO_INSTALL_LOCATION_EXTERNAL	"LOCATION_EXTERNAL"

/**
 * @brief Value to be used when filtering based on app-component
 */
#define	PMINFO_APPINFO_UI_APP				"UI_APP"

/**
 * @brief Value to be used when filtering based on app-component
 */
#define	PMINFO_APPINFO_SVC_APP				"SVC_APP"

typedef enum {
	PMINFO_HWACCELERATION_NOT_USE_GL = 0,		/**< Don't use hardware acceleration*/
	PMINFO_HWACCELERATION_USE_GL = 1,		/**< Use hardware acceleration*/
	PMINFO_HWACCELERATION_USE_SYSTEM_SETTING = 2		/**< Follow system setting for hardware acceleration */
}pkgmgrinfo_app_hwacceleration;

typedef enum {
	PMINFO_SCREENREADER_OFF = 0,		/**< Don't use screen reader*/
	PMINFO_SCREENREADER_ON = 1,		/**< Use screen reader*/
	PMINFO_SCREENREADER_USE_SYSTEM_SETTING = 2		/**< Follow system setting for screen reader */
}pkgmgrinfo_app_screenreader;

typedef enum {
	PMINFO_RECENTIMAGE_USE_ICON = 0,		/**<Use icon for recent image*/
	PMINFO_RECENTIMAGE_USE_CAPTURE = 1,		/**< Use capture for recent image*/
	PMINFO_RECENTIMAGE_USE_NOTHING = 2		/**< Don't use recent image */
}pkgmgrinfo_app_recentimage;

/**
 * @brief A handle to get package information
 */
typedef void* pkgmgrinfo_pkginfo_h;

/**
 * @brief A handle to get application information
 */
typedef void* pkgmgrinfo_appinfo_h;

/**
 * @brief A handle to get certificate information
 */
typedef void* pkgmgrinfo_certinfo_h;

/**
 * @brief A handle to insert package information
 */
typedef void* pkgmgrinfo_pkgdbinfo_h;

/**
 * @brief A handle to filter package information
 */
typedef void* pkgmgrinfo_pkginfo_filter_h;

/**
 * @brief A handle to filter application information
 */
typedef void* pkgmgrinfo_appinfo_filter_h;

/**
 * @brief A handle to filter application metadata  information
 */
typedef void* pkgmgrinfo_appinfo_metadata_filter_h;

/**
 * @brief A handle to get appcontrol information
 */
typedef void* pkgmgrinfo_appcontrol_h;

/**
 * @fn int (*pkgmgrinfo_pkg_list_cb ) (const pkgmgrinfo_pkginfo_h handle, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_pkginfo_get_list(), pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 *
 * @param[in] handle the pkginfo handle
 * @param[in] user_data user data passed to pkgmgrinfo_pkginfo_get_list(), pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_pkginfo_get_list()
 * @see  pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 */
typedef int (*pkgmgrinfo_pkg_list_cb ) (const pkgmgrinfo_pkginfo_h handle,
							void *user_data);

/**
 * @fn int (*pkgmgrinfo_app_list_cb ) (const pkgmgrinfo_appinfo_h handle, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_appinfo_get_list(), pkgmgrinfo_appinfo_filter_foreach_appinfo(), pkgmgrinfo_appinfo_metadata_filter_foreach()
 *
 * @param[in] handle the appinfo handle
 * @param[in] user_data user data passed to pkgmgrinfo_appinfo_get_list(), pkgmgrinfo_appinfo_filter_foreach_appinfo(), pkgmgrinfo_appinfo_metadata_filter_foreach()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_appinfo_get_list()
 * @see  pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @see  pkgmgrinfo_appinfo_metadata_filter_foreach()
 */
typedef int (*pkgmgrinfo_app_list_cb ) (const pkgmgrinfo_appinfo_h handle,
							void *user_data);

/**
 * @fn int (*pkgmgrinfo_app_category_list_cb ) (const char *category_name, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_appinfo_foreach_category()
 *
 * @param[in] category_name the name of the category
 * @param[in] user_data user data passed to pkgmgrinfo_appinfo_foreach_category()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_appinfo_foreach_category()
 */
typedef int (*pkgmgrinfo_app_category_list_cb ) (const char *category_name,
							void *user_data);

/**
 * @fn int (*pkgmgrinfo_app_permission_list_cb ) (const char *permission_type, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_appinfo_foreach_category()
 *
 * @param[in] permission_name the name of the permission
 * @param[in] user_data user data passed to pkgmgrinfo_appinfo_foreach_category()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_appinfo_foreach_category()
 */
typedef int (*pkgmgrinfo_app_permission_list_cb ) (const char *permission_type,
							void *user_data);

/**
 * @fn int (*pkgmgrinfo_pkg_privilege_list_cb ) (const char *privilege_name, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_pkginfo_foreach_privilege()
 *
 * @param[in] privilege_name the name of the privilege
 * @param[in] user_data user data passed to pkgmgrinfo_pkginfo_foreach_privilege()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_pkginfo_foreach_privilege()
 */
typedef int (*pkgmgrinfo_pkg_privilege_list_cb ) (const char *privilege_name,
							void *user_data);

/**
 * @fn int (*pkgmgrinfo_app_metadata_list_cb ) (const char *metadata_key, const char *metadata_value, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_appinfo_foreach_metadata()
 *
 * @param[in] metadata_name the name of the metadata
 * @param[in] metadata_value the value of the metadata
 * @param[in] user_data user data passed to pkgmgrinfo_appinfo_foreach_metadata()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_appinfo_foreach_metadata()
 */
typedef int (*pkgmgrinfo_app_metadata_list_cb ) (const char *metadata_key,
							const char *metadata_value, void *user_data);

/**
 * @fn int (*pkgmgrinfo_app_control_list_cb ) (pkgmgrinfo_appcontrol_h handle, void *user_data)
 *
 * @brief Specifies the type of function passed to pkgmgrinfo_appinfo_foreach_appcontrol()
 *
 * @param[in] handle the appcontrol handle to be used to get operation, uri and mime info
 * @param[in] user_data user data passed to pkgmgrinfo_appinfo_foreach_appcontrol()
 *
 * @return 0 if success, negative value(<0) if fail. Callback is not called if return value is negative.\n
 *
 * @see  pkgmgrinfo_appinfo_foreach_appcontrol()
 */
typedef int (*pkgmgrinfo_app_control_list_cb ) (pkgmgrinfo_appcontrol_h handle,
							void *user_data);

/**
 * @brief Install Location Types
 */
typedef enum {
	PMINFO_INSTALL_LOCATION_AUTO = 0,		/**< Auto*/
	PMINFO_INSTALL_LOCATION_INTERNAL_ONLY,		/**< Internal Installation*/
	PMINFO_INSTALL_LOCATION_PREFER_EXTERNAL,		/**< External Installation*/
}pkgmgrinfo_install_location;

/**
 * @brief Application Component Types
 */
typedef enum {
	PMINFO_ALL_APP = 0,	/**< All Application*/
	PMINFO_UI_APP,		/**< UI Application*/
	PMINFO_SVC_APP,		/**< Service Application*/
}pkgmgrinfo_app_component;

/**
 * @brief Application Storage Types
 */
typedef enum {
	PMINFO_INTERNAL_STORAGE = 0,		/**< Internal Storage*/
	PMINFO_EXTERNAL_STORAGE = 1,		/**< External Storage*/
}pkgmgrinfo_installed_storage;

/**
 * @brief Certificate Types to be used for getting information
 */
typedef enum {
	PMINFO_AUTHOR_ROOT_CERT = 0,		/**< Author Root Certificate*/
	PMINFO_AUTHOR_INTERMEDIATE_CERT = 1,		/**< Author Intermediate Certificate*/
	PMINFO_AUTHOR_SIGNER_CERT = 2,		/**< Author Signer Certificate*/
	PMINFO_DISTRIBUTOR_ROOT_CERT = 3,		/**< Distributor Root Certificate*/
	PMINFO_DISTRIBUTOR_INTERMEDIATE_CERT = 4,		/**< Distributor Intermediate Certificate*/
	PMINFO_DISTRIBUTOR_SIGNER_CERT = 5,		/**< Distributor Signer Certificate*/
	PMINFO_DISTRIBUTOR2_ROOT_CERT = 6,		/**< End Entity Root Certificate*/
	PMINFO_DISTRIBUTOR2_INTERMEDIATE_CERT = 7,		/**< End Entity Intermediate Certificate*/
	PMINFO_DISTRIBUTOR2_SIGNER_CERT = 8,		/**< End Entity Signer Certificate*/
}pkgmgrinfo_cert_type;

/**
 * @brief Install Location Types to be used when setting data in DB
 */
typedef enum {
	INSTALL_INTERNAL = 0,		/**< Internal Installation*/
	INSTALL_EXTERNAL,		/**< External Installation*/
} INSTALL_LOCATION;

 /**
  * @brief permission Types
  */
 typedef enum {
	 PMINFO_PERMISSION_NORMAL = 0,		 /**< permission normal*/
	 PMINFO_PERMISSION_SIGNATURE, 	 /**< permission type is signature*/
	 PMINFO_PERMISSION_PRIVILEGE, 	 /**< permission type is privilege*/
 }pkgmgrinfo_permission_type;


 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_ID		"PMINFO_PKGINFO_PROP_PACKAGE_ID"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_TYPE	"PMINFO_PKGINFO_PROP_PACKAGE_TYPE"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_VERSION	"PMINFO_PKGINFO_PROP_PACKAGE_VERSION"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_INSTALL_LOCATION		"PMINFO_PKGINFO_PROP_PACKAGE_INSTALL_LOCATION"
  /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_INSTALLED_STORAGE		"PMINFO_PKGINFO_PROP_PACKAGE_INSTALLED_STORAGE"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_NAME		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_NAME"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_EMAIL		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_EMAIL"
 /** String property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_HREF		"PMINFO_PKGINFO_PROP_PACKAGE_AUTHOR_HREF"

 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_REMOVABLE		"PMINFO_PKGINFO_PROP_PACKAGE_REMOVABLE"
 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD		"PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD"
 /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_READONLY		"PMINFO_PKGINFO_PROP_PACKAGE_READONLY"
  /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_UPDATE		"PMINFO_PKGINFO_PROP_PACKAGE_UPDATE"
  /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_APPSETTING		"PMINFO_PKGINFO_PROP_PACKAGE_APPSETTING"
   /** Boolean property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_NODISPLAY_SETTING		"PMINFO_PKGINFO_PROP_PACKAGE_NODISPLAY_SETTING"

 /** Integer property for filtering based on package info*/
#define	PMINFO_PKGINFO_PROP_PACKAGE_SIZE		"PMINFO_PKGINFO_PROP_PACKAGE_SIZE"

 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ID		"PMINFO_APPINFO_PROP_APP_ID"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_COMPONENT		"PMINFO_APPINFO_PROP_APP_COMPONENT"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_EXEC		"PMINFO_APPINFO_PROP_APP_EXEC"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ICON		"PMINFO_APPINFO_PROP_APP_ICON"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_TYPE		"PMINFO_APPINFO_PROP_APP_TYPE"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_OPERATION	"PMINFO_APPINFO_PROP_APP_OPERATION"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_URI			"PMINFO_APPINFO_PROP_APP_URI"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_MIME		"PMINFO_APPINFO_PROP_APP_MIME"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_CATEGORY	"PMINFO_APPINFO_PROP_APP_CATEGORY"
 /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_HWACCELERATION	"PMINFO_APPINFO_PROP_APP_HWACCELERATION"
  /** String property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_SCREENREADER	"PMINFO_APPINFO_PROP_APP_SCREENREADER"

 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_NODISPLAY		"PMINFO_APPINFO_PROP_APP_NODISPLAY"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_MULTIPLE		"PMINFO_APPINFO_PROP_APP_MULTIPLE"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_ONBOOT			"PMINFO_APPINFO_PROP_APP_ONBOOT"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_AUTORESTART	"PMINFO_APPINFO_PROP_APP_AUTORESTART"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_TASKMANAGE	"PMINFO_APPINFO_PROP_APP_TASKMANAGE"
 /** Boolean property for filtering based on app info*/
#define	PMINFO_APPINFO_PROP_APP_LAUNCHCONDITION	"PMINFO_APPINFO_PROP_APP_LAUNCHCONDITION"

 /** will be updated*/
 /** string property for filtering based on pkg info*/
#define	PMINFO_PKGINFO_PROP_RANGE_BASIC	"PMINFO_PKGINFO_PROP_RANGE_BASIC"

/**
 * @fn	int pkgmgrinfo_pkginfo_get_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data)
 * @brief	This API gets list of installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	pkg_list_cb	iteration function for list
 * @param[in]	user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post	None
 * @code
int pkg_list_cb(pkgmgrinfo_pkginfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_pkginfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_pkgs()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_pkginfo_get_list(pkg_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_list(pkgmgrinfo_pkg_list_cb pkg_list_cb, void *user_data);

/**
 * @fn int pkgmgrinfo_pkginfo_get_pkginfo(const char *pkgid, pkgmgrinfo_pkginfo_h *handle)
 * @brief	This API creates the package information handle from db
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	pkgid	pointer to package ID
 * @param[out] handle		pointer to the package info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkginfo(const char *pkgid, pkgmgrinfo_pkginfo_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_get_pkgname(pkgmgrinfo_pkginfo_h handle, char **pkg_name)
 * @brief	This API gets the package name from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out]	pkg_name	pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_type()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_name(const char *pkgid)
{
	int ret = 0;
	char *pkgname = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_pkgname(handle, &pkgname);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgname: %s\n", pkgname);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkgname(pkgmgrinfo_pkginfo_h handle, char **pkg_name);

/**
 * @fn int pkgmgrinfo_pkginfo_get_pkgid(pkgmgrinfo_pkginfo_h handle, char **pkgid)
 * @brief	This API gets the package id from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out]	pkgid	pointer to hold package id
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_type()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkgid(const char *pkgid)
{
	int ret = 0;
	char *pkg_id = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_pkgid(handle, &pkg_id);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg id: %s\n", pkg_id);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_pkgid(pkgmgrinfo_pkginfo_h handle, char **pkgid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_type(pkgmgrinfo_pkginfo_h handle, char **type)
 * @brief	This API gets the package type from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] type		pointer to hold package type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_type(pkgmgrinfo_pkginfo_h handle, char **type);

/**
 * @fn int pkgmgrinfo_pkginfo_get_version(pkgmgrinfo_pkginfo_h handle, char **version)
 * @brief	This API gets the package version from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] version		pointer to hold package version
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_version(const char *pkgid)
{
	int ret = 0;
	char *version = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_version(handle, &version);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg version: %s\n", version);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_version(pkgmgrinfo_pkginfo_h handle, char **version);

/**
 * @fn int pkgmgrinfo_pkginfo_get_install_location(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_install_location *location)
 * @brief	This API gets the package install location from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to package info handle
 * @param[out] location		pointer to hold package install location
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_install_location(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_install_location location;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_install_location(handle, &location);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg install location: %d\n", location);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_install_location(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_install_location *location);

/**
 * @fn int pkgmgrinfo_pkginfo_get_package_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the package size from the package ID. size will be 0 if package install location is internal-only.
 size will be 0 if package install location is prefer-external but size is not specified in manifest file.Application should check
 the return value of pkgmgrinfo_pkginfo_get_install_location() and use it to distinguish the above cases.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_package_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgsize: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_package_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_total_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the installed package total size on the target.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package total size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_pkg_total_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_total_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg total size: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_pkginfo_get_total_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_data_size(pkgmgrinfo_pkginfo_h handle, int *size)
 * @brief	This API gets the installed package data size on the target.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] size		pointer to hold package data size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_pkg_data_size(const char *pkgid)
{
	int ret = 0;
	int size = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_data_size(handle, &size);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg data size: %d\n", size);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_pkginfo_get_data_size(pkgmgrinfo_pkginfo_h handle, int *size);

/**
 * @fn int pkgmgrinfo_pkginfo_get_icon(pkgmgrinfo_pkginfo_h handle, char **icon)
 * @brief	This API gets the package icon from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] icon		pointer to hold package icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_icon(const char *pkgid)
{
	int ret = 0;
	char *icon = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_icon(handle, &icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg icon: %s\n", icon);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_icon(pkgmgrinfo_pkginfo_h handle, char **icon);

/**
 * @fn int pkgmgrinfo_pkginfo_get_label(pkgmgrinfo_pkginfo_h handle, char **label)
 * @brief	This API gets the package label from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] label		pointer to hold package label
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_label(const char *pkgid)
{
	int ret = 0;
	char *label = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_label(handle, &label);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg label: %s\n", label);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_label(pkgmgrinfo_pkginfo_h handle, char **label);

/**
 * @fn int pkgmgrinfo_pkginfo_get_description(pkgmgrinfo_pkginfo_h handle, char **description)
 * @brief	This API gets the package description from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] description		pointer to hold package description
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_description(const char *pkgid)
{
	int ret = 0;
	char *description = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_description(handle, &description);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg description: %s\n", description);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_description(pkgmgrinfo_pkginfo_h handle, char **description);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_name(pkgmgrinfo_pkginfo_h handle, char **author_name)
 * @brief	This API gets the package's author name from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_name		pointer to hold package author name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_name(const char *pkgid)
{
	int ret = 0;
	char *author_name = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_name(handle, &author_name);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author name: %s\n", author_name);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_name(pkgmgrinfo_pkginfo_h handle, char **author_name);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_email(pkgmgrinfo_pkginfo_h handle, char **author_email)
 * @brief	This API gets the package's author email from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_email		pointer to hold package author email
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_email(const char *pkgid)
{
	int ret = 0;
	char *author_email = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_email(handle, &author_email);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author email: %s\n", author_email);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_email(pkgmgrinfo_pkginfo_h handle, char **author_email);

/**
 * @fn int pkgmgrinfo_pkginfo_get_author_href(pkgmgrinfo_pkginfo_h handle, char **author_href)
 * @brief	This API gets the package's author href from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] author_href		pointer to hold package author href
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_author_href(const char *pkgid)
{
	int ret = 0;
	char *author_href = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_author_href(handle, &author_href);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg author href: %s\n", author_href);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_author_href(pkgmgrinfo_pkginfo_h handle, char **author_href);

/**
 * @fn int pkgmgrinfo_pkginfo_get_installed_storage(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_installed_storage *storage)
 * @brief	This API gets the package installed storagae value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] storage		pointer to hold package installed storage
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_installed_storage(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_installed_storage storage;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_installed_storage(handle, &storage);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg installed storage: %d\n", storage);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_installed_storage(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_installed_storage *storage);

/**
 * @fn int pkgmgrinfo_pkginfo_get_installed_time(pkgmgrinfo_pkginfo_h handle, int *installed_time)
 * @brief	This API gets the installed time of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] installed_time		pointer to hold installed time of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_installed_time(const char *pkgid)
{
	int ret = 0;
	int installed_time = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_installed_time(handle, &installed_time);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("installed_time: %d\n", installed_time);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_installed_time(pkgmgrinfo_pkginfo_h handle, int *installed_time);

/**
 * @fn int pkgmgrinfo_pkginfo_get_storeclientid(pkgmgrinfo_pkginfo_h handle, char **storeclientid)
 * @brief	This API gets the store client id of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] storeclientid		pointer to hold store client id of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_storeclientid(const char *pkgid)
{
	int ret = 0;
	char *storeclientid = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_storeclientid(handle, &storeclientid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf(store client id: %s\n", storeclientid);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_storeclientid(pkgmgrinfo_pkginfo_h handle, char **storeclientid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_mainappid(pkgmgrinfo_pkginfo_h handle, char **mainappid)
 * @brief	This API gets the main app id of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] mainappid		pointer to hold main app id of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_mainappid(const char *pkgid)
{
	int ret = 0;
	char *mainappid = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_mainappid(handle, &mainappid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf(main app id: %s\n", mainappid);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_mainappid(pkgmgrinfo_pkginfo_h handle, char **mainappid);

/**
 * @fn int pkgmgrinfo_pkginfo_get_url(pkgmgrinfo_pkginfo_h handle, char **url)
 * @brief	This API gets the url of package from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] url		pointer to hold url of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_url(const char *pkgid)
{
	int ret = 0;
	char *url = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_url(handle, &url);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("url : %s\n", url);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_url(pkgmgrinfo_pkginfo_h handle, char **url);


/**
 * @fn int pkgmgrinfo_pkginfo_get_root_path(pkgmgrinfo_pkginfo_h handle, char **path)
 * @brief	This API gets the root path of package
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to package info handle
 * @param[out] path		pointer to hold root path of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_root_path(const char *pkgid)
{
	int ret = 0;
	char *path = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_pkginfo_get_root_path(handle, &path);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("path : %s\n", path);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_root_path(pkgmgrinfo_pkginfo_h handle, char **path);


/**
 * @fn int pkgmgrinfo_pkginfo_get_csc_path(pkgmgrinfo_pkginfo_h handle, char **path)
 * @brief	This API gets the csc path of package
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to package info handle
 * @param[out] path		pointer to hold csc path of package
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @code
static int get_csc_path(const char *pkgid)
{
	int ret = 0;
	char *path = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;

	ret = pkgmgrinfo_pkginfo_get_csc_path(handle, &path);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("path : %s\n", path);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);

	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_csc_path(pkgmgrinfo_pkginfo_h handle, char **path);

/**
 * @fn int pkgmgrinfo_pkginfo_compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
 * @brief	This API compare the cert information from given package id
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	lhs_package_id	pointer to first package ID
 * @param[in]	rhs_package_id	pointer to second package ID
 * @param[out] compare_result		pointer to the compare result.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
{
	int ret = 0;
	pkgmgrinfo_cert_compare_result_type_e result;

	ret = pkgmgrinfo_pkginfo_compare_pkg_cert_info(lhs_package_id, rhs_package_id, &result);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	printf("result: %d\n", result);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_compare_pkg_cert_info(const char *lhs_package_id, const char *rhs_package_id, pkgmgrinfo_cert_compare_result_type_e *compare_result);

/**
 * @fn int pkgmgrinfo_pkginfo_compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
 * @brief	This API compare the cert information from given app id
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	lhs_app_id	pointer to first app ID
 * @param[in]	rhs_app_id	pointer to second app ID
 * @param[out] compare_result		pointer to the compare result.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result)
{
	int ret = 0;
	pkgmgrinfo_cert_compare_result_type_e result;

	ret = pkgmgrinfo_pkginfo_compare_app_cert_info(lhs_app_id, rhs_app_id, &result);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	printf("result: %d\n", result);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_compare_app_cert_info(const char *lhs_app_id, const char *rhs_app_id, pkgmgrinfo_cert_compare_result_type_e *compare_result);

/**
 * @fn int pkgmgrinfo_pkginfo_is_removable(pkgmgrinfo_pkginfo_h handle, bool *removable)
 * @brief	This API gets the package 'removable' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] removable		pointer to hold package removable value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_removable(const char *pkgid)
{
	int ret = 0;
	bool removable;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_removable(handle, &removable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg removable: %d\n", removable);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_removable(pkgmgrinfo_pkginfo_h handle, bool *removable);

/**
 * @fn int pkgmgrinfo_pkginfo_is_movable(pkgmgrinfo_pkginfo_h handle, bool *movable)
 * @brief	This API check that the package can move internal storage to external storage or external storage to internal storage from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] movable		pointer to hold package movable state
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_pkg_movable(const char *pkgid)
{
	int ret = 0;
	bool movable;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_movable(handle, &movable);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg movable: %d\n", movable);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_movable(pkgmgrinfo_pkginfo_h handle, bool *movable);

/**
 * @fn int pkgmgrinfo_pkginfo_is_preload(pkgmgrinfo_pkginfo_h handle, bool *preload)
 * @brief	This API gets the package 'preload' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] preload		pointer to hold package preload value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_preload(const char *pkgid)
{
	int ret = 0;
	bool preload;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_preload(handle, &preload);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg preload: %d\n", preload);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_preload(pkgmgrinfo_pkginfo_h handle, bool *preload);

/**
 * @fn int pkgmgrinfo_pkginfo_is_system(pkgmgrinfo_pkginfo_h handle, bool *system)
 * @brief	This API gets the value for given handle is system or not
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] system		pointer to hold  system is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_system(const char *pkgid)
{
	int ret = 0;
	bool system = false;
	pkgmgrinfo_pkginfo_h handle = NULL;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_system(handle, &system);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg system: %d\n", system);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_system(pkgmgrinfo_pkginfo_h handle, bool *system);

/**
 * @fn int pkgmgrinfo_pkginfo_is_readonly(pkgmgrinfo_pkginfo_h handle, bool *readonly)
 * @brief	This API gets the package 'readonly' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] readonly	pointer to hold package readonly value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_readonly(const char *pkgid)
{
	int ret = 0;
	bool readonly;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_readonly(handle, &readonly);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg readonly: %d\n", readonly);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_readonly(pkgmgrinfo_pkginfo_h handle, bool *readonly);


/**
 * @fn int pkgmgrinfo_pkginfo_is_update(pkgmgrinfo_pkginfo_h handle, bool *update)
 * @brief	This API gets the package 'upate' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] update	pointer to hold package update value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @code
static int get_pkg_update(const char *pkgid)
{
	int ret = 0;
	bool update;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_update(handle, &update);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg update: %d\n", update);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_update(pkgmgrinfo_pkginfo_h handle, bool *update);

/**
 * @fn int pkgmgrinfo_pkginfo_is_accessible(pkgmgrinfo_pkginfo_h handle, bool *accessible)
 * @brief	This API gets the package 'accessible' value from the package ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to package info handle
 * @param[out] accessible	pointer to hold package accessible value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_readonly()
 * @code
static int get_pkg_accessible(const char *pkgid)
{
	int ret = 0;
	bool accessible;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_is_accessible(handle, &accessible);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkg accessible: %d\n", accessible);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_is_accessible(pkgmgrinfo_pkginfo_h handle, bool *accessible);

/**
 * @fn int pkgmgrinfo_pkginfo_destroy_pkginfo(pkgmgrinfo_pkginfo_h handle)
 * @brief	This API destroys the package information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to the package info handle
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_get_pkgid()
 * @see		pkgmgrinfo_pkginfo_is_removable()
 * @code
static int get_pkg_type(const char *pkgid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_get_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	printf("pkgtype: %s\n", type);
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_destroy_pkginfo(pkgmgrinfo_pkginfo_h handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_create(pkgmgrinfo_pkginfo_filter_h *handle)
 * @brief	This API creates the package information filter handle from db.  All filter properties will be ANDed.
 The query will search the entire package information collected from the manifest file of all the installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_rpm_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "rpm");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of rpm pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_create(pkgmgrinfo_pkginfo_filter_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_destroy(pkgmgrinfo_pkginfo_filter_h handle)
 * @brief	This API destroys the package information filter handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_rpm_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "rpm");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of rpm pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_destroy(pkgmgrinfo_pkginfo_filter_h handle);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_bool(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const bool value)
 * @brief	This API adds a boolean filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		boolean property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_preload_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_bool(handle, PMINFO_PKGINFO_PROP_PACKAGE_PRELOAD, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of preload pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_bool(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const bool value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_int(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const int value)
 * @brief	This API adds an integer filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		integer property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_int(handle, PMINFO_PKGINFO_PROP_PACKAGE_SIZE, 10);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of preload pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_int(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const int value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_add_string(pkgmgrinfo_pkginfo_filter_h handle, const char *property, const char *value)
 * @brief	This API adds a string filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] property		string property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_rpm_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "rpm");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of rpm pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_add_string(pkgmgrinfo_pkginfo_filter_h handle,
		const char *property, const char *value);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_foreach_pkginfo(pkgmgrinfo_pkginfo_filter_h handle, pkgmgrinfo_pkg_list_cb pkg_cb, void *user_data)
 * @brief	This API executes the user supplied callback function for each package that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] pkg_cb		callback function.
 * @param[in] user_data		user data to be passed to the callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_count()
 * @code
int pkg_list_cb(pkgmgrinfo_pkginfo_h handle, void *user_data)
{
	char *pkgid = NULL;
	pkgmgrinfo_pkginfo_get_pkgid(handle, &pkgid);
	printf("pkg id : %s\n", pkgid);
	return 0;
}

static int get_rpm_pkg_list()
{
	int ret = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "rpm");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_foreach_pkginfo(handle, pkg_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_foreach_pkginfo(pkgmgrinfo_pkginfo_filter_h handle,
		pkgmgrinfo_pkg_list_cb pkg_cb, void *user_data);

/**
 * @fn int pkgmgrinfo_pkginfo_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count)
 * @brief	This API counts the package that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package info filter handle.
 * @param[in] count		pointer to store the count value.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_filter_create()
 * @post		pkgmgrinfo_pkginfo_filter_destroy()
 * @see		pkgmgrinfo_pkginfo_filter_foreach_pkginfo()
 * @code
static int get_rpm_pkg_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_pkginfo_filter_h handle;
	ret = pkgmgrinfo_pkginfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_filter_add_string(handle, PMINFO_PKGINFO_PROP_PACKAGE_TYPE, "rpm");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_filter_destroy(handle);
		return -1;
	}
	printf("No of rpm pkgs: %d\n", count);
	pkgmgrinfo_pkginfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_filter_count(pkgmgrinfo_pkginfo_filter_h handle, int *count);

/**
 * @fn	int pkgmgrinfo_pkginfo_foreach_privilege(pkgmgrinfo_pkginfo_h handle,
			pkgmgrinfo_pkg_privilege_list_cb privilege_func, void *user_data);
 * @brief	This API gets the list of privilege for a particular package
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the package info handle.
 * @param[in]	privilege_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @code
int privilege_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_privilege(const char *package, char *privilege)
{
	int ret = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(package, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_foreach_privilege(handle, privilege_func, (void *)privilege);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_foreach_privilege(pkgmgrinfo_pkginfo_h handle,
			pkgmgrinfo_pkg_privilege_list_cb privilege_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_get_list(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_app_component component,
 pkgmgrinfo_app_list_cb app_func, void *user_data)
 * @brief	This API gets list of installed applications for a particular package
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		package info handle
 * @param[in]	component	application component
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_get_pkginfo()
 * @post		pkgmgrinfo_pkginfo_destroy_pkginfo()
 * @code
int app_func(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int list_apps(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkginfo_h handle;
	ret = pkgmgrinfo_pkginfo_get_pkginfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_list(handle, PMINFO_UI_APP, app_func, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
		return -1;
	}
	pkgmgrinfo_pkginfo_destroy_pkginfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_list(pkgmgrinfo_pkginfo_h handle, pkgmgrinfo_app_component component,
							pkgmgrinfo_app_list_cb app_func, void *user_data);
/**
 * @fn	int pkgmgrinfo_appinfo_get_install_list(pkgmgrinfo_app_list_cb app_func, void *user_data);
 * @brief	This API gets list of installed applications from all packages with  minimum informaion.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_apps()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_appinfo_get_install_list(app_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_install_list(pkgmgrinfo_app_list_cb app_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_get_installed_list(pkgmgrinfo_app_list_cb app_func, void *user_data);
 * @brief	This API gets list of installed applications from all packages.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	app_func		iteration function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *pkgid1 = NULL;
	char *pkgid2 = NULL;
	pkgid1 = (char *)user_data;
	pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid2);
	if (strcmp(pkgid1, pkgid2) == 0) {
		return -1;
	} else {
		return 0;
	}
}

static int list_apps()
{
	int ret = 0;
	char *name = "helloworld";
	ret = pkgmgrinfo_appinfo_get_installed_list(app_list_cb, (void *)name);
	if (ret != PMINFO_R_OK) {
		return -1;
	}
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_installed_list(pkgmgrinfo_app_list_cb app_func, void *user_data);

/**
 * @fn int pkgmgrinfo_appinfo_get_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle)
 * @brief	This API creates the application information handle from db
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	appid	pointer to appid
 * @param[out] handle		pointer to the application info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype: %s\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_appinfo(const char *appid, pkgmgrinfo_appinfo_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_get_appid(pkgmgrinfo_appinfo_h handle, char **appid)
 * @brief	This API gets the application ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] appid		pointer to hold appid
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_id(const char *appid)
{
	int ret = 0;
	char *app_id = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_appid(handle, &app_id);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app id: %s\n", app_id);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_appid(pkgmgrinfo_appinfo_h  handle, char **appid);

/**
 * @fn int pkgmgrinfo_appinfo_get_pkgname(pkgmgrinfo_appinfo_h handle, char **pkg_name)
 * @brief	This API gets the package name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] pkg_name		pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_pkgname(const char *appid)
{
	int ret = 0;
	char *pkgname = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_pkgname(handle, &pkgname);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("pkg name: %s\n", pkgname);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_pkgname(pkgmgrinfo_appinfo_h  handle, char **pkg_name);

/**
 * @fn int pkgmgrinfo_appinfo_get_pkgid(pkgmgrinfo_appinfo_h handle, char **pkgid)
 * @brief	This API gets the package id of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] pkgid		pointer to hold package id
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_pkgid(const char *appid)
{
	int ret = 0;
	char *pkgid = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_pkgid(handle, &pkgid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("pkg id: %s\n", pkgid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_pkgid(pkgmgrinfo_appinfo_h  handle, char **pkgid);

/**
 * @fn int pkgmgrinfo_appinfo_get_exec(pkgmgrinfo_appinfo_h handle, char **exec)
 * @brief	This API gets the executable name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] exec		pointer to hold app exec name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_exec(const char *appid)
{
	int ret = 0;
	char *exec = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_exec(handle, &exec);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("exec name: %s\n", exec);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_exec(pkgmgrinfo_appinfo_h  handle, char **exec);

/**
 * @fn int pkgmgrinfo_appinfo_get_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the icon name of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] icon		pointer to hold app icon name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_icon(const char *appid)
{
	int ret = 0;
	char *icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_icon(handle, &icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("icon name: %s\n", icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_label(pkgmgrinfo_appinfo_h handle, char **label)
 * @brief	This API gets the label of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] label		pointer to hold app label
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_label(const char *appid)
{
	int ret = 0;
	char *label = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_label(handle, &label);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("label : %s\n", label);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_label(pkgmgrinfo_appinfo_h  handle, char **label);

/**
 * @fn int pkgmgrinfo_appinfo_get_component(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_component *component)
 * @brief	This API gets the component of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] component		pointer to hold app component
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_component(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_component component;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_component(handle, &component);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("component : %s\n", component);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_component(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_component *component);

/**
 * @fn int pkgmgrinfo_appinfo_get_apptype(pkgmgrinfo_appinfo_h handle, char **app_type)
 * @brief	This API gets the apptype of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] app_type		pointer to hold apptype
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *apptype = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &apptype);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype : %s\n", apptype);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_apptype(pkgmgrinfo_appinfo_h  handle, char **app_type);

/**
 * @fn int pkgmgrinfo_appinfo_get_operation(pkgmgrinfo_appcontrol_h  handle,
										int *operation_count, char ***operation)
 * @brief	This API gets the list of operation of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] operation_count		pointer to hold number of operations
 * @param[out] operation		pointer to hold list of operations
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_mime()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int oc = 0;
	int i = 0;
	char **operation;
	pkgmgrinfo_appinfo_get_operation(handle, &oc, &operation);
	for (i = 0; i < oc; i++) {
		if (strcmp(operation[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_operation(const char *appid, char *operation)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)operation);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_operation(pkgmgrinfo_appcontrol_h  handle,
										int *operation_count, char ***operation);

/**
 * @fn int pkgmgrinfo_appinfo_get_uri(pkgmgrinfo_appcontrol_h  handle,
										int *uri_count, char ***uri)
 * @brief	This API gets the list of uri of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] uri_count		pointer to hold number of uris
 * @param[out] uri		pointer to hold list of uris
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @see		pkgmgrinfo_appinfo_get_mime()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int uc = 0;
	int i = 0;
	char **uri;
	pkgmgrinfo_appinfo_get_uri(handle, &uc, &uri);
	for (i = 0; i < uc; i++) {
		if (strcmp(uri[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_uri(const char *appid, char *uri)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)uri);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_uri(pkgmgrinfo_appcontrol_h  handle,
										int *uri_count, char ***uri);

/**
 * @fn int pkgmgrinfo_appinfo_get_mime(pkgmgrinfo_appcontrol_h  handle,
										int *mime_count, char ***mime)
 * @brief	This API gets the list of mime of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] mime_count		pointer to hold number of mimes
 * @param[out] mime		pointer to hold list of mimes
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int mc = 0;
	int i = 0;
	char **mime;
	pkgmgrinfo_appinfo_get_operation(handle, &mc, &mime);
	for (i = 0; i < mc; i++) {
		if (strcmp(mime[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_mime(const char *appid, char *mime)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)mime);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_mime(pkgmgrinfo_appcontrol_h  handle,
										int *mime_count, char ***mime);

/**
 * @fn int pkgmgrinfo_appinfo_get_subapp(pkgmgrinfo_appcontrol_h  handle,
										int *subapp_count, char ***subapp)
 * @brief	This API gets the list of subapp of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the appcontrol handle.
 * @param[out] subapp_count		pointer to hold number of subapp
 * @param[out] subapp		pointer to hold list of subapp
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_uri()
 * @see		pkgmgrinfo_appinfo_get_operation()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int sc = 0;
	int i = 0;
	char **subapp = NULL;
	pkgmgrinfo_appinfo_get_subapp(handle, &sc, &subapp);
	for (i = 0; i < sc; i++) {
		if (strcmp(subapp[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_subapp(const char *appid, char *subapp)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)subapp);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_subapp(pkgmgrinfo_appcontrol_h  handle,
						int *subapp_count, char ***subapp);

/**
 * @fn int pkgmgrinfo_appinfo_get_notification_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the notification icon of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] path		pointer to hold notification icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_notification_icon(const char *appid)
{
	int ret = 0;
	char *notification_icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_notification_icon(handle, &notification_icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("notification icon : %s\n", notification_icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_notification_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_setting_icon(pkgmgrinfo_appinfo_h handle, char **icon)
 * @brief	This API gets the setting icon of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] path		pointer to hold setting icon
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_setting_icon(const char *appid)
{
	int ret = 0;
	char *setting_icon = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_setting_icon(handle, &setting_icon);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("setting icon : %s\n", setting_icon);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_setting_icon(pkgmgrinfo_appinfo_h  handle, char **icon);

/**
 * @fn int pkgmgrinfo_appinfo_get_recent_image_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_recentimage *type)
 * @brief	This API gets the type of recent image on app-tray
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] type		pointer to hold image type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_recent_image_type(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_recentimage type;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_recent_image_type(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("recent image type: %d\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_recent_image_type(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_recentimage *type);


/**
 * @fn int pkgmgrinfo_appinfo_get_preview_image(pkgmgrinfo_appinfo_h  handle, char **preview_img)
 * @brief	This API gets the preview image of application
 *
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] preview_img		pointer to hold preview image path
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_previewimage(const char *appid)
{
	int ret = 0;
	char *preview = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_preview_image(handle, &preview);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("preview image path : %s\n", preview);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_preview_image(pkgmgrinfo_appinfo_h  handle, char **preview_img);


/**
 * @fn int pkgmgrinfo_appinfo_get_permission_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_permission_type *permission)
 * @brief	This API gets the package permission type of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] permission		pointer to hold package permission
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @code
static int get_app_permission(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_permission_type permission = 0;
	pkgmgrinfo_appinfo_h handle;

	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_permission_type(handle, &permission);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("permission type: %d\n", permission);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_permission_type(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_permission_type *permission);

/**
 * @fn int pkgmgrinfo_appinfo_get_component_type(pkgmgrinfo_appinfo_h handle, char **component_type)
 * @brief	This API gets the component_type
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] component_type		pointer to hold component_type
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_component_type(const char *appid)
{
	int ret = 0;
	char *component_type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_component_type(handle, &component_type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("component_type: %s\n", component_type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_component_type(pkgmgrinfo_appinfo_h  handle, char **component_type);

/**
 * @fn int pkgmgrinfo_appinfo_get_hwacceleration(pkgmgrinfo_appinfo_h handle, pkgmgrinfo_app_hwacceleration *hwacceleration)
 * @brief	This API gets the application 'hwacceleration' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] hwacceleration		pointer to hold package hwacceleration value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_hwacceleration(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_hwacceleration hwacceleration;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_hwacceleration(handle, &hwacceleration);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app hwacceleration: %d\n", hwacceleration);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_hwacceleration(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_hwacceleration *hwacceleration);

/**
 * @fn int pkgmgrinfo_appinfo_get_screenreader(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_screenreader *screenreader)
 * @brief	This API gets the application 'screenreader' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] screenreader		pointer to hold package accessibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post	pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_screenreader(const char *appid)
{
	int ret = 0;
	pkgmgrinfo_app_screenreader screenreader = PMINFO_USE_SYSTEM_SETTING;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_screenreader(handle, &screenreader);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app screenreader: %d\n", screenreader);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_screenreader(pkgmgrinfo_appinfo_h  handle, pkgmgrinfo_app_screenreader *screenreader);

/**
 * @fn int pkgmgrinfo_appinfo_get_effectimage(pkgmgrinfo_appinfo_h  handle, char **portrait_img, char **landscape_img)
 * @brief	This API gets the application's landscape & portrait effect images
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]  portrait_img contains portrait mode effect image
 * @param[out]  landscape_img contains landscape mode effect image
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_effectimages(const char *appid)
{
	int ret = 0;
	char *portraitimg = NULL;
	char *landscapeimg = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_effectimage(handle, &portraitimg, &landscapeimg);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app effect image portrait: %s, app effect image landscape : %s\n", portraitimg, landscapeimg);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_effectimage(pkgmgrinfo_appinfo_h  handle, char **portrait_img, char **landscape_img);

/**
 * @fn int pkgmgrinfo_appinfo_get_submode_mainid(pkgmgrinfo_appinfo_h handle, char **submode_mainid)
 * @brief	This API gets the submode_mainid of the application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @param[out] submode_mainid		pointer to hold package name
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_submode_mainid(const char *appid)
{
	int ret = 0;
	char *submode_mainid = NULL;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_submode_mainid(handle, &submode_mainid);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("submode_mainid: %s\n", submode_mainid);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_get_submode_mainid(pkgmgrinfo_appinfo_h  handle, char **submode_mainid);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_permission(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_permission_list_cb permission_func, void *user_data);
 * @brief	This API gets the list of permission for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	permission_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int permission_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_permission(const char *appid, char *permission)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_permission(handle, permission_func, (void *)permission);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_permission(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_permission_list_cb permission_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_category(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_category_list_cb category_func, void *user_data);
 * @brief	This API gets the list of category for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	category_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int category_func(const char *name, void *user_data)
{
	if (strcmp(name, (char *)user_data) == 0)
		return -1;
	else
		return 0;
}

static int list_category(const char *appid, char *category)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_category(handle, category_func, (void *)category);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_category(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_category_list_cb category_func, void *user_data);

/**
 * @fn	int pkgmgrinfo_appinfo_foreach_metadata(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_metadata_list_cb metadata_func, void *user_data);
 * @brief	This API gets the list of metadata for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	metadata_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int metadata_func(const char *key, const char *value, void *user_data)
{
	if (strcmp(key, (char *)user_data) == 0) {
		printf("Value is %s\n", value);
		return -1;
	}
	else
		return 0;
}

static int list_metadata(const char *appid, char *key)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_metadata(handle, metadata_func, (void *)key);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_metadata(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_metadata_list_cb metadata_func, void *user_data);


/**
 * @fn	int pkgmgrinfo_appinfo_foreach_appcontrol(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_control_list_cb appcontrol_func, void *user_data);
 * @brief	This API gets the list of app-control for a particular application
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 * @param[in]	handle		pointer to the application info handle.
 * @param[in]	appcontrol_func		callback function for list
 * @param[in] user_data	user data to be passed to callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @code
int appcontrol_func(pkgmgrinfo_appcontrol_h handle, void *user_data)
{
	int oc = 0;
	int i = 0;
	char **operation;
	pkgmgrinfo_appinfo_get_operation(handle, &oc, &operation);
	for (i = 0; i < oc; i++) {
		if (strcmp(operation[i], (char *)user_data) == 0)
			return -1;
		else
			return 0;
	}
}

static int check_operation(const char *appid, char *operation)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_foreach_appcontrol(handle, appcontrol_func, (void *)operation);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_foreach_appcontrol(pkgmgrinfo_appinfo_h handle,
			pkgmgrinfo_app_control_list_cb appcontrol_func, void *user_data);

/**
 * @fn int pkgmgrinfo_appinfo_is_nodisplay(pkgmgrinfo_appinfo_h handle, bool *nodisplay)
 * @brief	This API gets the application 'nodisplay' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] nodisplay		pointer to hold package nodisplay value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_nodisplay(const char *appid)
{
	int ret = 0;
	bool nodisplay;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_nodisplay(handle, &nodisplay);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app nodisplay: %d\n", nodisplay);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_nodisplay(pkgmgrinfo_appinfo_h  handle, bool *nodisplay);

/**
 * @fn int pkgmgrinfo_appinfo_is_multiple(pkgmgrinfo_appinfo_h handle, bool *multiple)
 * @brief	This API gets the application 'multiple' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] multiple		pointer to hold package multiple value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_multiple(const char *appid)
{
	int ret = 0;
	bool multiple;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_multiple(handle, &multiple);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app multiple: %d\n", multiple);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_multiple(pkgmgrinfo_appinfo_h  handle, bool *multiple);

/**
 * @fn int pkgmgrinfo_appinfo_is_indicator_display_allowed(pkgmgrinfo_appinfo_h handle, bool *indicator_disp)
 * @brief	This API gets the application 'indicatordisplay' value. If true, indicator will be displayed during
 *		application launching effect. If fales, indicator will be hidden during application launching effect
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out]  indicator_disp contains indicator display status for application launching effect
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_nodisplay()
 * @code
static int get_app_indicator_display(const char *appid)
{
	int ret = 0;
	bool indicator_disp;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_indicator_display_allowed(handle, &indicator_disp);
	if (ret != PMINFO_R_OK){
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app indicator disp : %d\n", indicator_disp);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_indicator_display_allowed(pkgmgrinfo_appinfo_h handle, bool *indicator_disp);

/**
 * @fn int pkgmgrinfo_appinfo_is_taskmanage(pkgmgrinfo_appinfo_h handle, bool *taskmanage)
 * @brief	This API gets the application 'taskmanage' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] taskmanage		pointer to hold package taskmanage value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_taskmanage(const char *appid)
{
	int ret = 0;
	bool taskmanage;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_taskmanage(handle, &taskmanage);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app taskmanage: %d\n", taskmanage);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_taskmanage(pkgmgrinfo_appinfo_h  handle, bool *taskmanage);

/**
 * @fn int pkgmgrinfo_appinfo_is_enabled(pkgmgrinfo_appinfo_h handle, bool *enabled)
 * @brief	This API gets the application 'taskmanage' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] enabled		pointer to hold package enabled value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_enabled(const char *appid)
{
	int ret = 0;
	bool enabled;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_taskmanage(handle, &enabled);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app enabled: %d\n", enabled);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_enabled(pkgmgrinfo_appinfo_h  handle, bool *enabled);

/**
 * @fn int pkgmgrinfo_appinfo_is_onboot(pkgmgrinfo_appinfo_h handle, bool *onboot)
 * @brief	This API gets the application 'onboot' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] onboot		pointer to hold package onboot value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_onboot(const char *appid)
{
	int ret = 0;
	bool onboot;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_onboot(handle, &onboot);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app onboot: %d\n", onboot);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_onboot(pkgmgrinfo_appinfo_h  handle, bool *onboot);

/**
 * @fn int pkgmgrinfo_appinfo_is_autorestart(pkgmgrinfo_appinfo_h handle, bool *autorestart)
 * @brief	This API gets the application 'autorestart' value from the app ID
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] autorestart		pointer to hold package autorestart value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_autorestart(const char *appid)
{
	int ret = 0;
	bool autorestart;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_autorestart(handle, &autorestart);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app autorestart: %d\n", autorestart);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_autorestart(pkgmgrinfo_appinfo_h  handle, bool *autorestart);

/**
 * @fn int pkgmgrinfo_appinfo_is_mainapp(pkgmgrinfo_appinfo_h  handle, bool *mainapp)
 * @brief	This API gets the value for given application is main app or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] mainapp		pointer to hold package mainapp is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_mainapp(const char *appid)
{
	int ret = 0;
	bool mainapp;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_mainapp(handle, &mainapp);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("mainapp: %d\n", mainapp);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_mainapp(pkgmgrinfo_appinfo_h  handle, bool *mainapp);


/**
 * @fn int pkgmgrinfo_appinfo_is_preload(pkgmgrinfo_appinfo_h handle, bool *preload)
 * @brief	This API gets the value for given application is preload or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] preload		pointer to hold preload is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_preload(const char *appid)
{
	int ret = 0;
	bool preload = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_preload(handle, &preload);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("preload: %d\n", preload);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_preload(pkgmgrinfo_appinfo_h handle, bool *preload);

/**
 * @fn int pkgmgrinfo_appinfo_is_submode(pkgmgrinfo_appinfo_h handle, bool *submode)
 * @brief	This API gets the value for given application is submode or not from handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] submode		pointer to hold submode is or not
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_submode(const char *appid)
{
	int ret = 0;
	bool submode = 0;
	pkgmgrinfo_appinfo_h handle = NULL;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_submode(handle, &submode);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("submode: %d\n", submode);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_is_submode(pkgmgrinfo_appinfo_h handle, bool *submode);

/**
 * @fn int pkgmgrinfo_appinfo_destroy_appinfo(pkgmgrinfo_appinfo_h handle)
 * @brief	This API destroys the application information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		None
 * @see		pkgmgrinfo_appinfo_get_pkgid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_type(const char *appid)
{
	int ret = 0;
	char *type = NULL;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_get_apptype(handle, &type);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("apptype: %s\n", type);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_destroy_appinfo(pkgmgrinfo_appinfo_h  handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_create(pkgmgrinfo_appinfo_filter_h *handle)
 * @brief	This API creates the application information filter handle from db.  All filter properties will be ANDed.
 The query will search the entire application information collected from the manifest file of all the installed packages
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the application info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_create(pkgmgrinfo_appinfo_filter_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_destroy(pkgmgrinfo_appinfo_filter_h handle)
 * @brief	This API destroys the application information filter handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		None
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_destroy(pkgmgrinfo_appinfo_filter_h handle);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_bool(pkgmgrinfo_appinfo_filter_h handle, const char *property, const bool value)
 * @brief	This API adds a boolean filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		boolean property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_taskmanageable_app_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_bool(handle, PMINFO_APPINFO_PROP_APP_TASKMANAGE, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of taskmanageable apps: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_bool(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const bool value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_int(pkgmgrinfo_appinfo_filter_h handle, const char *property, const int value)
 * @brief	This API adds an integer filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		integer property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_taskmanageable_app_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_bool(handle, PMINFO_APPINFO_PROP_APP_XXX, 10);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of apps: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_int(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const int value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_add_string(pkgmgrinfo_appinfo_filter_h handle, const char *property, const char *value)
 * @brief	This API adds a string filter property to the filter handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] property		string property name.
 * @param[in] value		value corresponding to the property.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_add_string(pkgmgrinfo_appinfo_filter_h handle,
		const char *property, const char *value);

/**
 * @fn int pkgmgrinfo_appinfo_filter_foreach_appinfo(pkgmgrinfo_appinfo_filter_h handle, pkgmgrinfo_app_list_cb app_cb, void *user_data)
 * @brief	This API executes the user supplied callback function for each application that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] app_cb		callback function.
 * @param[in] user_data		user data to be passed to the callback function
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_count()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_capp_list()
{
	int ret = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_foreach_appinfo(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_foreach_appinfo(pkgmgrinfo_appinfo_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data);

/**
 * @fn int pkgmgrinfo_appinfo_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count)
 * @brief	This API counts the application that satisfy the filter conditions
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application info filter handle.
 * @param[in] count		pointer to store count value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_filter_create()
 * @post		pkgmgrinfo_appinfo_filter_destroy()
 * @see		pkgmgrinfo_appinfo_filter_foreach_appinfo()
 * @code
static int get_capp_count()
{
	int ret = 0;
	int count = 0;
	pkgmgrinfo_appinfo_filter_h handle;
	ret = pkgmgrinfo_appinfo_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_filter_add_string(handle, PMINFO_APPINFO_PROP_APP_TYPE, "capp");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_filter_count(handle, &count);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_filter_destroy(handle);
		return -1;
	}
	printf("No of capp: %d\n", count);
	pkgmgrinfo_appinfo_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_filter_count(pkgmgrinfo_appinfo_filter_h handle, int *count);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_create(pkgmgrinfo_appinfo_metadata_filter_h *handle)
 * @brief	This API creates the application's metadata  information filter handle from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the application metadata info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_create(pkgmgrinfo_appinfo_metadata_filter_h *handle);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_destroy(pkgmgrinfo_appinfo_metadata_filter_h handle)
 * @brief	This API destroys the application's metadata  information filter handle.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		None
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_destroy(pkgmgrinfo_appinfo_metadata_filter_h handle);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_add(pkgmgrinfo_appinfo_metadata_filter_h handle, const char *key, const char *value)
 * @brief	This API adds filter condition for the query API.  The query will search the entire application metadata  information collected from
 * the manifest file of all the installed packages. You can specify value as NULL to search based on key only.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @param[in] key			pointer to metadata key
 * @param[in] value			pointer to metadata value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		pkgmgrinfo_appinfo_metadata_filter_foreach(), pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @see		pkgmgrinfo_appinfo_metadata_filter_foreach()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_add(pkgmgrinfo_appinfo_metadata_filter_h handle,
		const char *key, const char *value);

/**
 * @fn int pkgmgrinfo_appinfo_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle, pkgmgrinfo_app_list_cb app_cb, void *user_data)
 * @brief	This API executes the filter query. The query will search the entire application metadata  information collected from
 * the manifest file of all the installed packages. For each application returned by the query, the callback will be called. If callback returns
 * negative value, no more callbacks will be called and API will return.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the application metadata info filter handle.
 * @param[in] app_cb		function pointer to callback
 * @param[in] user_data		pointer to user data
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_metadata_filter_create()
 * @post		pkgmgrinfo_appinfo_metadata_filter_destroy()
 * @code
int app_list_cb(pkgmgrinfo_appinfo_h handle, void *user_data)
{
	char *appid = NULL;
	pkgmgrinfo_appinfo_get_appid(handle, &appid);
	printf("appid : %s\n", appid);
	return 0;
}

static int get_app_list(const char *mkey, const char *mvalue)
{
	int ret = 0;
	pkgmgrinfo_appinfo_metadata_filter_h handle;
	ret = pkgmgrinfo_appinfo_metadata_filter_create(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_metadata_filter_add(handle, mkey, mvalue);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	ret = pkgmgrinfo_appinfo_metadata_filter_foreach(handle, app_list_cb, NULL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_metadata_filter_destroy(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_appinfo_metadata_filter_foreach(pkgmgrinfo_appinfo_metadata_filter_h handle,
		pkgmgrinfo_app_list_cb app_cb, void *user_data);

/**
 * @fn int pkgmgrinfo_pkginfo_create_certinfo(pkgmgrinfo_certinfo_h *handle)
 * @brief	This API creates the package cert information handle to get data from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_get_cert_value()
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_create_certinfo(pkgmgrinfo_certinfo_h *handle);

/**
 * @fn int pkgmgrinfo_pkginfo_load_certinfo(const char *pkgid, pkgmgrinfo_certinfo_h handle)
 * @brief	This API loads the package cert information handle with data from db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_get_cert_value()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_load_certinfo(const char *pkgid, pkgmgrinfo_certinfo_h handle);

/**
 * @fn int pkgmgrinfo_pkginfo_get_cert_value(pkgmgrinfo_certinfo_h handle, pkgmgrinfo_cert_type cert_type, const char **cert_value)
 * @brief	This API gets the package cert information from the handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @param[in] cert_type		certificate type
 * @param[out] cert_value	pointer to hold certificate value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		pkgmgrinfo_pkginfo_destroy_certinfo()
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_get_cert_value(pkgmgrinfo_certinfo_h handle, pkgmgrinfo_cert_type cert_type, const char **cert_value);

/**
 * @fn int pkgmgrinfo_pkginfo_destroy_certinfo(pkgmgrinfo_certinfo_h handle)
 * @brief	This API destroys the package cert information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_pkginfo_create_certinfo()
 * @post		None
 * @see		pkgmgrinfo_pkginfo_load_certinfo()
 * @code
static int get_cert_info(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_certinfo_h handle;
	char *auth_cert = NULL;
	ret = pkgmgrinfo_pkginfo_create_certinfo(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_pkginfo_load_certinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_pkginfo_get_cert_value(handle, PMINFO_AUTHOR_ROOT_CERT, &auth_cert);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_pkginfo_destroy_certinfo(handle);
		return -1;
	}
	printf("Author root certificate: %s\n", auth_root);
	pkgmgrinfo_pkginfo_destroy_certinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_pkginfo_destroy_certinfo(pkgmgrinfo_certinfo_h handle);

/**
 * @fn int pkgmgrinfo_delete_certinfo(const char *pkgid)
 * @brief	This API deletes the package cert information from DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		None
 * @code
static int delete_cert_info(const char *pkgid)
{
	int ret = 0;
	ret = pkgmgrinfo_delete_certinfo(pkgid);
	if (ret != PMINFO_R_OK)
		return -1;
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_delete_certinfo(const char *pkgid);

/**
 * @fn int pkgmgrinfo_create_pkgdbinfo(const char *pkgid, pkgmgrinfo_pkgdbinfo_h *handle)
 * @brief	This API creates the package db information handle to set data in db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid	pointer to the package ID.
 * @param[out] handle		pointer to the package db info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_version_to_pkgdbinfo(handle, "0.0.1");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_create_pkgdbinfo(const char *pkgid, pkgmgrinfo_pkgdbinfo_h *handle);

/**
 * @fn int pkgmgrinfo_set_type_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *type)
 * @brief	This API sets the package type in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] type		pointer to the package type.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_version_to_pkgdbinfo()
 * @code
static int set_pkg_type_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_type_to_pkgdbinfo(handle, "wgt");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_type_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *type);

/**
 * @fn int pkgmgrinfo_set_version_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *version)
 * @brief	This API sets the package version in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] version		pointer to the package version
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_version_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_version_to_pkgdbinfo(handle, "0.0.1");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_version_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *version);

/**
 * @fn int pkgmgrinfo_set_install_location_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, INSTALL_LOCATION location)
 * @brief	This API sets the package install location in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] location	package install location
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_install_location_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_install_location_to_pkgdbinfo(handle, INSTALL_INTERNAL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_install_location_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, INSTALL_LOCATION location);

/**
 * @fn int pkgmgrinfo_set_size_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *size)
 * @brief	This API sets the package size in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] size		pointer to the package size
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_size_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_size_to_pkgdbinfo(handle, "15");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_size_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *size);

/**
 * @fn int pkgmgrinfo_set_label_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *label, const char *locale)
 * @brief	This API sets the package label in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] label		pointer to the package label
 * @param[in] locale	pointer to the locale
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_label_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_label_to_pkgdbinfo(handle, "helloworld", "en-us");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_label_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *label, const char *locale);

/**
 * @fn int pkgmgrinfo_set_icon_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *icon, const char *locale)
 * @brief	This API sets the package icon in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] icon		pointer to the package icon
 * @param[in] locale	pointer to the locale
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_icon_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_icon_to_pkgdbinfo(handle, "helloworld.png", "en-us");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_icon_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *icon, const char *locale);

/**
 * @fn int pkgmgrinfo_set_description_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *description, const char *locale)
 * @brief	This API sets the package description in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] description		pointer to the package description
 * @param[in] locale	pointer to the locale
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_description_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_description_to_pkgdbinfo(handle, "helloworld application", "en-us");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_description_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *description, const char *locale);

/**
 * @fn int pkgmgrinfo_set_author_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *author_name,
 const char *author_email, const char *author_href, const char *locale)
 * @brief	This API sets the package author info in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] author_name		pointer to the package author name
 * @param[in] author_email		pointer to the package author email
 * @param[in] author_href		pointer to the package author href
 * @param[in] locale	pointer to the locale
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_author_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_author_to_pkgdbinfo(handle, "John", "john@samsung.com", "www.samsung.com", "en-us");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_author_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, const char *author_name,
			const char *author_email, const char *author_href, const char *locale);

/**
 * @fn int pkgmgrinfo_set_removable_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, int removable)
 * @brief	This API sets the package 'removable' value in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] removable		package removable value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_removable_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_removable_to_pkgdbinfo(handle, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_removable_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, int removable);

/**
 * @fn int pkgmgrinfo_set_preload_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, int preload)
 * @brief	This API sets the package 'preload' value in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] preload		package preload value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_preload_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_preload_to_pkgdbinfo(handle, 1);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_preload_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, int preload);

/**
 * @fn int pkgmgrinfo_set_installed_storage_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, INSTALL_LOCATION location)
 * @brief	This API sets the package 'installed_storage' value in db handle
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle	pointer to the pkgdbinfo handle.
 * @param[in] location		installed_storage value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @code
static int set_pkg_installed_storage_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_installed_storage_to_pkgdbinfo(handle, INSTALL_INTERNAL);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_installed_storage_to_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle, INSTALL_LOCATION location);

/**
 * @fn int pkgmgrinfo_save_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle)
 * @brief	This API saves all the information from the handle to the DB.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package db info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		pkgmgrinfo_destroy_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_version_to_pkgdbinfo(handle, "0.0.1");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_save_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle);

/**
 * @fn int pkgmgrinfo_destroy_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle)
 * @brief	This API destroys the package db information handle freeing up all the resources
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package db info handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_pkgdbinfo()
 * @post		None
 * @see		pkgmgrinfo_save_pkgdbinfo()
 * @see		pkgmgrinfo_set_type_to_pkgdbinfo()
 * @code
static int set_pkg_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_pkgdbinfo_h handle;
	ret = pkgmgrinfo_create_pkgdbinfo(pkgid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_version_to_pkgdbinfo(handle, "0.0.1");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_pkgdbinfo(handle);
		return -1;
	}
	pkgmgrinfo_destroy_pkgdbinfo(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_destroy_pkgdbinfo(pkgmgrinfo_pkgdbinfo_h handle);


/**
 * @fn int pkgmgrinfo_create_certinfo_set_handle(pkgmgrinfo_instcertinfo_h *handle)
 * @brief	This API creates the package cert information handle to set data in db.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[out] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		None
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_set_cert_value()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_create_certinfo_set_handle(pkgmgrinfo_instcertinfo_h *handle);

/**
 * @fn int pkgmgrinfo_set_cert_value(pkgmgrinfo_instcertinfo_h handle, pkgmgrinfo_instcert_type cert_type, char *cert_value)
 * @brief	This API sets the package cert information in the handle.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @param[in] cert_type		certificate type.
 * @param[in] cert_value	certificate value.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_set_cert_value(pkgmgrinfo_instcertinfo_h handle, pkgmgrinfo_instcert_type cert_type, char *cert_value);

/**
 * @fn int pkgmgrinfo_save_certinfo(const char *pkgid, pkgmgrinfo_instcertinfo_h handle)
 * @brief	This API saves the package cert information in the DB.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] pkgid		pointer to the package ID.
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		pkgmgrinfo_destroy_certinfo_set_handle()
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_save_certinfo(const char *pkgid, pkgmgrinfo_instcertinfo_h handle);

/**
 * @fn int pkgmgrinfo_destroy_certinfo_set_handle(pkgmgrinfo_instcertinfo_h handle)
 * @brief	This API destroys the package cert information handle freeing up all the resources.
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] handle		pointer to the package cert handle.
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_create_certinfo_set_handle()
 * @post		None
 * @see		pkgmgrinfo_save_certinfo()
 * @code
static int set_cert_in_db(const char *pkgid)
{
	int ret = 0;
	pkgmgrinfo_instcertinfo_h handle;
	ret = pkgmgrinfo_create_certinfo_set_handle(&handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_set_cert_value(handle, PMINFO_SET_AUTHOR_ROOT_CERT, "author root certificate");
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	ret = pkgmgrinfo_save_pkgdbinfo(pkgid, handle);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_destroy_certinfo_set_handle(handle);
		return -1;
	}
	pkgmgrinfo_destroy_certinfo_set_handle(handle);
	return 0;
}
 * @endcode
 */
int pkgmgrinfo_destroy_certinfo_set_handle(pkgmgrinfo_instcertinfo_h handle);

/**
 * @fn int pkgmgrinfo_datacontrol_get_info(const char *providerid, const char * type, char **appid, char **access)
 * @brief	This API gets the datacontrol info
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in] providerid		pointer to the providerid of dataconltrol.
 * @param[in] type			pointer to the type of dataconltrol.
 * @param[out] appid			pointer to hold appid, need to free after using
 * @param[out] access			pointer to hold access, need to free after using
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @endcode
 */
int pkgmgrinfo_datacontrol_get_info(const char *providerid, const char * type, char **appid, char **access);

/**
 * @fn int pkgmgrinfo_appinfo_is_guestmode_appstatus(pkgmgrinfo_appinfo_h handle, bool *status)
 * @brief	This API gets the application 'guest mode visibility' value from the DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] status		pointer to hold app guest mode visibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int get_app_guestmode_visibility(const char *appid)
{
	int ret = 0;
	bool status;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_is_guestmode_visibility(handle, &status);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	printf("app guest mode visibility: %d\n", status);
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_appinfo_is_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool *status);

/**
 * @fn int pkgmgrinfo_appinfo_set_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool status)
 * @brief	This API sets the application 'guest mode visibility' value in the DB
 *
 * @par		This API is for package-manager client application
 * @par Sync (or) Async : Synchronous API
 *
 * @param[in]	handle	pointer to application info handle
 * @param[out] status	app guest mode visibility value
 * @return	0 if success, error code(<0) if fail
 * @retval	PMINFO_R_OK	success
 * @retval	PMINFO_R_EINVAL	invalid argument
 * @retval	PMINFO_R_ERROR	internal error
 * @pre		pkgmgrinfo_appinfo_get_appinfo()
 * @post		pkgmgrinfo_appinfo_destroy_appinfo()
 * @see		pkgmgrinfo_appinfo_get_appid()
 * @see		pkgmgrinfo_appinfo_is_multiple()
 * @code
static int set_app_guestmode_visibility(const char *appid, bool value)
{
	int ret = 0;
	pkgmgrinfo_appinfo_h handle;
	ret = pkgmgrinfo_appinfo_get_appinfo(appid, &handle);
	if (ret != PMINFO_R_OK)
		return -1;
	ret = pkgmgrinfo_appinfo_set_guestmode_visibility(handle, value);
	if (ret != PMINFO_R_OK) {
		pkgmgrinfo_appinfo_destroy_appinfo(handle);
		return -1;
	}
	pkgmgrinfo_appinfo_destroy_appinfo(handle);
	return 0;
}
 * @endcode
 */
 int pkgmgrinfo_appinfo_set_guestmode_visibility(pkgmgrinfo_appinfo_h handle, bool status);


/** @} */
#ifdef __cplusplus
}
#endif
#endif				/* __PKG_INFO_H__ */
/**
 * @}
 * @}
 */

